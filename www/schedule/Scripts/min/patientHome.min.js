//@ sourceURL=timer.js

// This module represent simple timer which can be used in order to display count up or down timer.
// Timer separated from UI representation, so it possible customize output.
(function($, snap) {
    "use strict";

    snap.namespace("snap.common").use("snap.admin.schedule.TimeUtils")
        .define("timer", function($timeUtils) {
            var defaultOptions = {
                countDown: false, // Count timer up or down.
                time: 0, // Time (the number of seconds) which will be shown in timer.
                onTimerTickCallback: null // Timer tick callback.
            };

            function Timer(opt) {
                var start,
                    time = opt.time,
                    countDown = opt.countDown,
                    onTimerTickCallback = opt.onTimerTickCallback,
                    intervalID = null;

                function timer() {
                    // get the number of seconds that have pass since
                    // startTimer() was called
                    var t = (((Date.now() - start) / 1000) | 0);
                    var diff = countDown ? time - t : time + t;

                    if (onTimerTickCallback) {
                        onTimerTickCallback($timeUtils.parseTimeInterval(diff));
                    }
                }

                this.start = function() {
                    start = Date.now();

                    // we don't want to wait a full second before the timer starts
                    timer();
                    intervalID = setInterval(timer, 1000);
                };

                this.stop = function() {
                    if (intervalID !== null) {
                        clearInterval(intervalID);
                        intervalID = null;
                    }
                };

                this.setTime = function(newTime) {
                    this.stop();

                    time = newTime;
                };
            }

            this.createTimer = function(options) {
                return new Timer($.extend({}, defaultOptions, options));
            };
        }).singleton();
}(jQuery, snap));
(function($, snap) {
    "use strict";
    snap.namespace("snap.service").using(["snapHttp"]).define("availabilityBlockService", function($http) {
        var abApiUrl = snap.baseUrl + "/api/v2.1/clinicians/availability-blocks",
            apptApiUrl = snap.baseUrl + "/api/v2.1/clinicians/appointments";
        var codeSetsDS = new snap.dataSource.codeSetDataSourceWrapper(["consultprimaryconcerns", "consultsecondaryconcerns"]);

        this.getAvailabilityBlocks = function(opt) {
            var path = abApiUrl;

            return $http.get(path, {
                ClinicianIds: opt.clinicianIds,
                StartDate: opt.startDate,
                EndDate: opt.endDate
            });
        };

        this.getSingleAvailabilityBlock = function(blockId) {
            var path = [abApiUrl, blockId].join("/");

            return $http.get(path);
        };

        this.addAvailabilityBlock = function(block) {
            var path = abApiUrl;

            return $.ajax({
                type: "POST",
                url: path,
                contentType: "application/json; charset=utf-8",
                dataType: "json",
                data: JSON.stringify(block),
            });

        };

        this.updateAvailabilityBlock = function(block, blockId) {
            var path = [abApiUrl, blockId].join("/");

            return $.ajax({
                type: "PUT",
                url: path,
                contentType: "application/json; charset=utf-8",
                dataType: "json",
                data: JSON.stringify(block),
            });
        };

        this.deleteAvailabilityBlock = function(blockId) {
            var path = [abApiUrl, blockId].join("/");

            return $.ajax({
                type: "DELETE",
                url: path,
                contentType: "application/json; charset=utf-8",
                dataType: "text"
            });
        };

        this.deleteAvailabilityBlockRule = function(blockId, ruleId) {
            var path = [abApiUrl, blockId, "rule", ruleId].join("/");

            return $.ajax({
                type: "DELETE",
                url: path,
                contentType: "application/json; charset=utf-8",
                dataType: "text"
            });
        };

        this.getAvailabilityBlockClinician = function(blockId) {
            var path = [abApiUrl, blockId, "clinicians"].join("/");

            return $http.get(path);
        };

        this.getAppointmentsForClinician = function(opt) {
            var path = apptApiUrl;

            return $http.get(path, opt);
        };

        this.getAppointmentsForPatient = function(opt) {
            return $http.get(snap.baseUrl + "/api/v2.1/patients/filtered-appointments", opt);
        };


        this.getAppointment = function(apptId) {
            var path = [apptApiUrl, apptId].join("/");

            return $http.get(path);
        };

        this.getAppointmentForpatient = function(apptId) {
            var path = [snap.baseUrl + "/api/v2.1/patients/appointments", apptId].join("/");

            return $http.get(path);
        };

        /************************ Appointments *************************/
        this.addAppointment = function(appt) {
            var path = apptApiUrl;

            return $.ajax({
                type: "POST",
                url: path,
                contentType: "application/json; charset=utf-8",
                dataType: "json",
                data: JSON.stringify(appt),
            });
        };

        this.updateAppointment = function(appt, apptId) {
            var path = [apptApiUrl, apptId].join("/");

            return $.ajax({
                type: "PUT",
                url: path,
                contentType: "application/json; charset=utf-8",
                dataType: "json",
                data: JSON.stringify(appt),
            });
        };

        this.deleteAppointment = function(apptId) {
            var path = [apptApiUrl, apptId].join("/");

            return $.ajax({
                type: "DELETE",
                url: path,
                contentType: "application/json; charset=utf-8",
                dataType: "text"
            });
        };

        /************************ COVERAGES *************************/
        this.getCoverageBlocks = function(filters) {
            var dfd = $.Deferred();
            if (filters.type !== "all") {
                $http.get(snap.baseUrl + '/api/v2.1/clinicians/availability-blocks/coverage', filters).done(function(coverageBlocks) {
                    var blocks = extendBlockArrayWithType(coverageBlocks.data, filters.type);
                    dfd.resolve({ data: blocks, total: blocks.length });
                }).fail(function() {
                    dfd.reject();
                });
            } else {
                $.when(
                    $http.get(snap.baseUrl + '/api/v2.1/clinicians/availability-blocks/coverage', $.extend({}, filters, { type: "onDemand" })),
                    $http.get(snap.baseUrl + '/api/v2.1/clinicians/availability-blocks/coverage', $.extend({}, filters, { type: "patientScheduled" })),
                    $http.get(snap.baseUrl + '/api/v2.1/clinicians/availability-blocks/coverage', $.extend({}, filters, { type: "adminScheduled" })),
                    $http.get(snap.baseUrl + '/api/v2.1/clinicians/availability-blocks/coverage', $.extend({}, filters, { type: "unavailable" }))
                ).done(function(onDemand, patientScheduled, adminScheduled, unavailable) {
                    var blocks = [].concat(
                        extendBlockArrayWithType(onDemand[0].data, 'onDemand'),
                        extendBlockArrayWithType(patientScheduled[0].data, 'patientScheduled'),
                        extendBlockArrayWithType(adminScheduled[0].data, 'adminScheduled'),
                        extendBlockArrayWithType(unavailable[0].data, 'unavailable')
                    );
                    dfd.resolve({ data: blocks, total: blocks.length });
                }).fail(function() {
                    dfd.reject();
                });
            }

            return dfd.promise();

            function extendBlockArrayWithType(coverageBlocks, coverageBlockType) {
                return coverageBlocks.map(function(item) {
                    return $.extend({}, item, { type: coverageBlockType });
                });
            }
        };

        /************************ ENCOUNTER DIALOG *************************/

        this.saveEncounterDocument = function(encDoc) {
            var path = snap.baseUrl + "/api/v2.1/clinicians/documentencounter";

            return $.ajax({
                type: "POST",
                url: path,
                contentType: "application/json; charset=utf-8",
                dataType: "json",
                data: JSON.stringify(encDoc),
            });
        };

        /************************ CONCERNS **************************/
        this.getPrimaryConcerns = function() {
            var def = $.Deferred();
            codeSetsDS.getItemIdByName("primary", snap.hospitalSession.hospitalId, "other").done(function(codeId) {
                if (codeId !== null) {
                    def.resolve(codeSetsDS.getCodeSetDataSourceReplacingNames(
                        "primary",
                        snap.hospitalSession.hospitalId, [
                            "Other"
                        ], [{
                            "codeId": codeId,
                            "text": "Other (provide details below)"
                        }]
                    ));
                } else {
                    def.resolve(codeSetsDS.getCodeSetDataSourceAddingObjects(
                        "primary", snap.hospitalSession.hospitalId, [{
                            "codeId": -1,
                            "text": "Other (provide details below)"
                        }]));
                }
            });

            return def.promise();
        };

        this.getSecondaryConcerns = function() {
            var def = $.Deferred();
            codeSetsDS.getItemIdByName("secondary", snap.hospitalSession.hospitalId, "other").done(function(codeId) {
                if (codeId !== null) {
                    def.resolve(codeSetsDS.getCodeSetDataSourceReplacingNames(
                        "secondary",
                        snap.hospitalSession.hospitalId, [
                            "Other"
                        ], [{
                            "codeId": codeId,
                            "text": "Other (provide details below)"
                        }]
                    ));
                } else {
                    def.resolve(codeSetsDS.getCodeSetDataSourceAddingObjects(
                        "secondary", snap.hospitalSession.hospitalId, [{
                            "codeId": -2,
                            "text": "Other (provide details below)"
                        }]));
                }
            });
            return def.promise();
        };

        /************************ PERSON **************************/
        this.getPatientList = function(providerId, searchText, take, skip) {
            var path = [snap.baseUrl + "/api/v2.1/providers", providerId, "patients"].join("/");
            var parameters = {
                take: take,
                skip: skip
            };
            if (!!searchText) {
                parameters.search = searchText;
            }
            return $http.get(path, parameters);
        };

        this.getClinicianList = function(providerId) {
            var path = [snap.baseUrl + "/api/v2.1/providers", providerId, "clinicians"].join("/");

            return $http.get(path);
        };

        this.getAllStaffAccountsForScheduling = function(providerId) {
            var path = [snap.baseUrl + "/api/v2.1/providers/", providerId, "/clinicians?roleFunctions=", snap.security.conduct_virtual_consultations].join("");

            return $http.get(path);
        };

        this.getPersonByEmail = function(email, userType) {
            var path = snap.baseUrl + "/api/v2.1/people?email=" + email;

            if (userType) {
                path += "&userType=" + userType;
            }

            return $http.get(path);
        };

        this.getUserCurrentTime = function() {
            return $http.get(snap.baseUrl + "/api/v2.1/users/current-time");
        };

        this.getPatientProfile = function(providerId, patientId) {
            var path = [snap.baseUrl + "/api/v2.1/providers", providerId, "patients", patientId].join("/");

            return $.ajax({
                type: "GET",
                url: path,
                contentType: "application/json; charset=utf-8",
                dataType: "json",
            });
        };
        this.getPatientProfilesForPatient = function (opt) {
            var path = snap.baseUrl + "/api/v2.1/patients/authorized-patients";
            var parameters = opt || {};

            return $.ajax({
                type: "GET",
                url: path,
                contentType: "application/json; charset=utf-8",
                dataType: "json",
                data: parameters
            });
        };
        this.getPatientProfileForPatient = function (patientId) {
            var path = [snap.baseUrl + "/api/v2.1/patients/authorized-patients", patientId].join("/");
            return $.ajax({
                type: "GET",
                url: path,
                contentType: "application/json; charset=utf-8",
                dataType: "json"
            });
        };
        this.getClinicianProfile = function(providerId, clinicianId) {
            var path = [snap.baseUrl + "/api/v2.1/providers", providerId, "users", clinicianId, "clinician/person"].join("/");

            return $.ajax({
                type: "GET",
                url: path,
                contentType: "application/json; charset=utf-8",
                dataType: "json",
            });
        };
        this.convertTime = function(opt) {
            var path = snap.baseUrl + "/api/v2.1/convert-time";
            return $http.get(path, opt);
        };
        this.getTimeZones = function() {
            var path = snap.baseUrl + "/api/v2/timezones";
            return $http.get(path);
        };

    }).singleton();
}(jQuery, window.snap = window.snap || {}));
/// <reference path="../core/snap.core.js" />
/// <reference path="../core/snapHttp.js" />
/// <reference path="../jquery-2.1.3.js" />
;
(function($, snap) {
    "use strict";

    snap.namespace("snap.DataService").using(["snapHttp"]).define("customerDataService", function($http) {
        this.createOnDemandConsltation = function(onDemandRequest) {
            return $.ajax({
                url: [snap.baseUrl, "/api/v2/patients/consultations"].join(""),
                type: "POST",
                data: JSON.stringify(onDemandRequest),
                contentType: "application/json; charset=utf-8",
                dataType: "json"
            });
        };
        this.createConsultationFromAppointment = function(personId, appointmentId) {
            return $.ajax({
                url: [snap.baseUrl, "/api/v2.1/patients/", personId, "/encounters"].join(""),
                type: "POST",
                data: JSON.stringify({
                    appointmentId: appointmentId,
                }),
                contentType: "application/json; charset=utf-8",
                dataType: "json",
            });
        };
        this.useExistingCreditForConsultation = function(patientId, consultationId) {
            return $.ajax({
                url: [snap.baseUrl, "/api/v2.1/patients/", patientId, "/payments/debits?errorIfNoCredits=false"].join(""),
                type: "POST",
                data: JSON.stringify({
                    consultationId: consultationId,
                }),
                contentType: "application/json; charset=utf-8",
                dataType: "json",
                error: function() { snapError("Failed to find Credits") }
            });
        };
        this.checkPaymentStatus = function(consultationId) {
            return $.ajax({
                url: [snap.baseUrl, "/api/v2/patients/copay/", consultationId, "/paymentstatus"].join(""),
                type: "GET",
                contentType: "application/json; charset=utf-8",
                dataType: "json",
                error: function() { snapError("Payment Processing Failure"); }
            });
        };
        this.updateConsultationMetadata = function(consultationId, intakeData) {
            return $.ajax({
                url: [snap.baseUrl, "/api/v2/patients/consultations/", consultationId, "/intake"].join(""),
                type: "PUT",
                data: JSON.stringify(intakeData),
                contentType: "application/json; charset=utf-8",
                dataType: "json"
            });

        };
        this.getAvailableConsultation = function() {
            return $http.get([snap.baseUrl, "/api/v2/patients/availableconsultations"].join(""));
        };
        this.getScheduledConsultation = function() {
            return $http.get([snap.baseUrl, "/api/v2.1/patients/appointments?includePatientCoUsers=false"].join(""));
        };
        this.getOnDemand = function() {
            return $.ajax({
                type: "GET",
                url: "/api/v2.1/patients/ondemand/availability",
                contentType: "application/json; charset=utf-8",
                dataType: "json"
            });
        };
        this.deleteActiveConsultations = function(consultationId) {
            return $.ajax({
                type: "DELETE",
                url: [snap.baseUrl, "/api/v2/patients/activeconsultations/", consultationId].join(""),
                contentType: "application/json; charset=utf-8",
                error: function() { snapInfo("Could not end the consultation. The Clincian might have already completed the session.") }
            });

        };
        this.getPatientCredits = function(patientId) {
            return $.ajax({
                type: "GET",
                url: snap.baseUrl + "/api/v2.1/patients/" + patientId + "/payments/credits",
                contentType: "application/json; charset=utf-8",
                dataType: "json"
            });
        };
        this.getActiveConsultations = function() {
            return $.ajax({
                type: "GET",
                url: snap.baseUrl + "/api/v2/patients/consultations/activeconsultations",
                contentType: "application/json; charset=utf-8",
                dataType: "json"
            });
        };

        this.markAppointmentAsFullfilled = function(consultationId) {
            return $.ajax({
                url: snap.baseUrl + "/api/v2.1/patients/consultations/" + consultationId + "/markasfullfill",
                type: "POST",
                contentType: "application/json; charset=utf-8",
                dataType: "json"
            });
        };

        this.getAccountUserProfiles = function(patientId, authorizedOnly) {
            if (patientId) {
                return $http.get([snap.baseUrl, "/api/v2/patients/" + patientId + "/familygroup/adults", authorizedOnly ? "?authorizedOnly=true" : ""].join(""));
            } else {
                return $http.get([snap.baseUrl, "/api/v2/patients/familygroup/adults", authorizedOnly ? "?authorizedOnly=true" : ""].join(""));
            }
        };
        this.getAccountDependentProfiles = function(patientId) {
            if (patientId) {
                return $http.get([snap.baseUrl, "/api/v2/patients/" + patientId + "/familyprofiles/dependents"].join(""));
            } else {
                return $http.get([snap.baseUrl, "/api/v2/patients/familyprofiles/dependents"].join(""));
            }
        };

        this.getPatientProfile = function(patientId) {
            return $http.get([snap.baseUrl, "/api/v2/patients/profiles/", patientId]);
        };

        this.getPatientProfileDetails = function(patientId, include) {
            return $http.get([snap.baseUrl, "/api/v2/patients/profile/", patientId, "?include=" + include].join(""));
        };

        this.getDefaultPatientProfileDetails = function(include) {
            return $http.get([snap.baseUrl, "/api/v2/patients/profile/?include=" + include].join(""));
        };
        this.editPatientProfile = function(data) {
            return $.ajax({
                url: [snap.baseUrl, "/api/patients/profile"].join(""),
                type: "PUT",
                data: JSON.stringify(data),
                contentType: "application/json; charset=utf-8",
                dataType: "json"
            });
        };

        this.addPatientProfile = function(data) {
            return $.ajax({
                url: [snap.baseUrl, "/api/v2/familygroups/dependents"].join(""),
                type: "POST",
                data: JSON.stringify(data),
                contentType: "application/json; charset=utf-8",
                dataType: "json"
            });
        };
        this.addDependentAsAdmin = function(patientId, data) {
            return $.ajax({
                url: [snap.baseUrl, "/api/v2/admin/patient/", patientId, "/dependent"].join(""),
                type: "POST",
                data: JSON.stringify(data),
                contentType: "application/json; charset=utf-8",
                dataType: "json"
            });
        };
        this.editRelationAndAuthorization = function(patientId, data) {
            return $.ajax({
                url: [snap.baseUrl, "/api/v2/patients/familygroup/", patientId, "/relationship"].join(""),
                type: "PUT",
                data: JSON.stringify(data),
                contentType: "application/json; charset=utf-8",
                dataType: "json"
            });
        };
        this.editRelationAndAuthorizationAsAdmin = function(guardianId, patientId, data) {
            return $.ajax({
                url: [snap.baseUrl, "/api/v2/admin/patient/", guardianId, "/dependent/", patientId, "/relationship"].join(""),
                type: "PUT",
                data: JSON.stringify(data),
                contentType: "application/json; charset=utf-8",
                dataType: "json"
            });
        };
        this.getAccountDetails = function() {
            return $http.get([snap.baseUrl, "/api/v2/patients/accountSettings"].join(""));
        };
        this.updateAccountDetails = function(data) {
            return $.ajax([snap.baseUrl, "/api/v2/patients/accountSettings"].join(""), { type: "PUT", data: data });
        };
        this.getUserCurrentTimeId = function() {
            var promise = $.Deferred();
            var counter = 2;

            function get() {
                $http.get(snap.baseUrl + "/api/v2.1/users/current-time").done(function(responce) {
                    promise.resolve(responce);
                }).fail(function() {
                    if (counter > 0) {
                        counter--;
                        get();
                    } else {
                        snap.redirectToLogin();
                        promise.reject();
                    }
                });
            }
            get();
            return promise.promise();
        };

        this.isResponseRulesActive = function() {
            return $http.get([snap.baseUrl, "/api/v2.1/patients/response-rules-active"].join(""));
        };

        this.updatePatientResponseAddress = function(address) {
            return $.ajax({
                url: [snap.baseUrl, "/api/v2.1/patients/encounter/address?addressText=", address].join(""),
                type: "PUT",
                contentType: "application/json; charset=utf-8",
                dataType: "json"
            });
        };

        this.getProviderLicensePatientAddressMetaRule = function() {
            return $.ajax({
                url: [snap.baseUrl, "/api/v2.1/admin/rules/patient-provider-license-meta-rules"].join(""),
                type: "GET",
                contentType: "application/json; charset=utf-8",
                dataType: "json"
            });
        };

    }).singleton();

}(jQuery, window.snap = window.snap || {}));

(function($, snap) {
    "use strict";
    snap.namespace("snap.service").using(["snapHttp"]).define("serviceTypesService", function($http) {
        var apiPath = snap.baseUrl + "/api/v2.1/service-types";

        this.get = function(hospitalId) {
            return $.ajax({
                url: apiPath,
                type: "GET",
                data: { providerId: hospitalId },
            });

            //return $http.get([apiPath, hospitalId].join("/"));
        };

        this.create = function(serviceType) {
            return $.ajax({
                url: apiPath,
                type: "POST",
                dataType: "json",
                contentType: "application/json; charset=utf-8",
                data: JSON.stringify(serviceType)
            });
        };

        this.update = function(serviceType) {
            return $.ajax({
                url: [apiPath, serviceType.serviceTypeId].join("/"),
                type: "PUT",
                dataType: "json",
                contentType: "application/json; charset=utf-8",
                data: JSON.stringify(serviceType)
            });
        };

        this.delete = function(serviceTypeId) {
            return $.ajax({
                url: [apiPath, serviceTypeId].join("/"),
                type: "DELETE"
            });
        }

        this.reorder = function(serviceTypes) {
            return $.ajax({
                url: [apiPath, "reorder"].join("/"),
                type: "PATCH",
                dataType: "json",
                contentType: "application/json; charset=utf-8",
                data: JSON.stringify(serviceTypes)
            });
        };
    }).singleton();
}(jQuery, window.snap = window.snap || {}));
(function($, snap) {
    "use strict";
    // API models provide Clinician, Patients and Group API in a slightly different format.
    // In order to use all API models in a same way (search lists, selectors, ...) we will parse them to the one common format.


    // Scheduler required Clinicians, Patients and Groups list.
    // In order to use all data sources in a same way we create common API.

    snap.namespace("snap.admin.schedule").use(["snapNotification", "snap.common.schedule.ScheduleCommon", "snap.DataService.customerDataService", "snap.service.availabilityBlockService"])
        .define("AdminScheduleDSFactory", function($snapNotification, $scheduleCommon, $customerDataService, $availabilityBlockService) {

            function CachedDS(items) {
                var localItems = items;

                this.selectById = function(id) {
                    return selectBy(id, "id");
                };

                this.selectByPersonId = function(personId) {
                    return selectBy(personId, "personId");
                };

                function selectBy(value, propertyName) {
                    var selectedItem = null;
                    for (var i = 0; i < localItems.length; i++) {
                        if (localItems[i][propertyName] === value) {
                            selectedItem = localItems[i];
                        }
                    }

                    return selectedItem;
                }
            }

            function LocalDS(items) {
                CachedDS.call(this, items);
                var localItems = items;
                this.selectByName = function(name) {
                    var filtered;
                    if (typeof(name) === "undefined" || name === null || name === "") {
                        filtered = localItems;
                    } else {
                        filtered = localItems.filter(function(item) {
                            return name === "" || item.name.toLowerCase().indexOf(name.toLowerCase()) > -1;
                        });
                    }

                    return filtered;
                };


            }

            function DS() {
                this.read = function(nameFilter) {
                    var dfd = $.Deferred();

                    this._getDS(nameFilter).done(function(ds) {
                        dfd.resolve(ds.selectByName(nameFilter));
                    });

                    return dfd.promise();
                };

                this.selectById = function(id) {
                    var df = $.Deferred();

                    if (id) {
                        this._getDS().done(function(ds) {
                            df.resolve(ds.selectById(id));
                        });
                    } else {
                        df.resolve(null);
                    }

                    return df.promise();
                };

                this.selectByPersonId = function(id) {
                    var df = $.Deferred();

                    if (id) {
                        this._getDS().done(function(ds) {
                            df.resolve(ds.selectByPersonId(id));
                        });
                    } else {
                        df.resolve(null);
                    }

                    return df.promise();
                };

                this.getLocalDS = function() {
                    return this._getDS();
                };
            }

            function CliniciansDS() {

                //****************** Call BASE constructor ********************

                DS.call(this);

                var cliniciansDS = null;
                var cliniciansData = null;

                this.getCliniciansData = function() {
                    var dfd = $.Deferred();
                    if (cliniciansData) {
                        dfd.resolve(cliniciansData);
                    } else {
                        this._getDS().done(function() {
                            dfd.resolve(cliniciansData);
                        });
                    }
                    return dfd.promise();
                };

                this._getDS = function() {
                    var dfd = $.Deferred();

                    if (cliniciansDS) {
                        dfd.resolve(cliniciansDS);
                    } else {
                        $availabilityBlockService.getAllStaffAccountsForScheduling(snap.hospitalSession.hospitalId).done(function(clinicians) {
                            cliniciansData = clinicians.data;
                            var data = clinicians.data.map(function(clinician) {
                                clinician.person.providerId = clinician.providerId;
                                return {
                                    id: clinician.userId,
                                    personId: clinician.person.id,
                                    name: $scheduleCommon.getFullName(clinician.person),
                                    imageSource: clinician.person.photoUrl || getDefaultProfileImageForClinician(),
                                    info: $scheduleCommon.getSpeciality(clinician.specialty),
                                    data: clinician,
                                    personType: "clinician",
                                };
                            });

                            cliniciansDS = new LocalDS(data);
                            dfd.resolve(cliniciansDS);
                        });
                    }

                    return dfd.promise();
                };
            }

            function PatientsDS() {

                // ****************** Call BASE constructor ********************

                DS.call(this);

                this._read = function(nameFilter) {
                    var dfd = $.Deferred();

                    this._getDS(nameFilter).done(function(ds) {
                        dfd.resolve(ds.selectByName(nameFilter));
                    });

                    return dfd.promise();
                };

                var patientsDS = null;
                this._getDS = function(nameFilter) {
                    var dfd = $.Deferred();

                    // if (patientsDS) {
                    //     dfd.resolve(patientsDS);
                    //   } else {
                    $availabilityBlockService.getPatientList(snap.hospitalSession.hospitalId, nameFilter, 20, 0).done(function(patients) {
                        var data = patients.data.map(function(patient) {
                            patient.person.providerId = patient.providerId;
                            return {
                                id: patient.patientId,
                                personId: patient.person.id,
                                name: $scheduleCommon.getFullName(patient.person),
                                imageSource: patient.person.photoUrl || getDefaultProfileImageForPatient(),
                                info: $scheduleCommon.getPhoneNumber(patient.person),
                                data: patient,
                                personType: "patient",
                            };
                        });

                        patientsDS = new NonFilteringDS(data);
                        dfd.resolve(patientsDS);
                    });
                    //   }

                    return dfd.promise();
                };
            }

            function EmptyDS() {
                // ****************** Call BASE constructor ********************
                DS.call(this);

                this._read = function(nameFilter) {
                    var dfd = $.Deferred();

                    this._getDS(nameFilter).done(function(ds) {
                        dfd.resolve(ds.selectByName(nameFilter));
                    });

                    return dfd.promise();
                };

                var emptyDS = null;
                this._getDS = function() {
                    var dfd = $.Deferred();
                    if (!emptyDS) {
                        emptyDS = new NonFilteringDS([]);
                    }
                    dfd.resolve(emptyDS);

                    return dfd.promise();
                };
            }


            this.createLocalDS = function(items) {
                return new LocalDS(items);
            };

            var patientsDS = null;
            this.getPatientsDS = function() {
                return new kendo.data.DataSource({
                    batch: true,
                    transport: {
                        read: {
                            url: [snap.baseUrl + '/api/v2.1/providers/', snap.hospitalSession.hospitalId, '/patients'].join(''),
                            dataType: "json",
                            contentType: 'application/json',
                            type: "get"
                        },
                        parameterMap: function(data, type) {
                            if (type !== "read") {
                                return JSON.stringify({ data: data.models });
                            } else {
                                if (data.searchText) {
                                    data.search = data.searchText;
                                    delete data.searchText;
                                }

                                return data;
                            }
                        }
                    },
                    error: function(e) {
                        $scheduleCommon.handleDataSourceError(e, "Patients list");
                    },
                    schema: {
                        data: function(patients) {
                            var data = patients.data.map(function(patient) {
                                patient.person.providerId = patient.providerId;
                                return {
                                    id: patient.patientId,
                                    personId: patient.person.id,
                                    name: $scheduleCommon.getFullName(patient.person),
                                    imageSource: patient.person.photoUrl || getDefaultProfileImageForPatient(),
                                    info: $scheduleCommon.getPhoneNumber(patient.person),
                                    data: patient,
                                    personType: "patient",
                                };
                            });

                            return data;
                        },
                        total: "total",

                    },
                    pageSize: 30,
                    serverPaging: true
                });
            };

            var clinicianDS = null;
            this.getCliniciansDS = function() {
                if (clinicianDS === null) {
                    clinicianDS = new CliniciansDS();
                }

                return clinicianDS;
            };

            this.getNewEmptyDS = function() {
                return new EmptyDS();
            };

            this.getNewPatientsDS = function() {
                return new PatientsDS();
            };

            this.getNewCliniciansDS = function() {
                return new CliniciansDS();
            };
        }).singleton();

    // Kendo UI has incosistence time API, some controls can automatically use UTC another works only with local times.
    //   This module help simplify all cases when you need to work with UTC time.


}(jQuery, snap));
//@ sourceURL=adminScheduleEventFactory.viewmodel.js

(function($, snap, kendo) {
    "use strict";

    snap.namespace("snap.admin.schedule").use(["snap.admin.schedule.TimeUtils"])
        .define("Repeater", function($timeUtils) {
            var events = {
                onRepeaterChange: "onRepeaterChange",
                onRepeaterClose: "onRepeaterClose",
                onDateChange: "onDateChange"
            };

            var repeatPeriodEnum = {
                daily: 0,
                weekly: 1
            };

            var emptyRepeatRule = {
                id: null,
                modifiedDate: null,
                repeatPeriod: repeatPeriodEnum.weekly,
                repeatInterval: 1,
                toDate: null,
                repeatOn: [],

            };

            function wrapDaysOfWeekToObservableObjects(selectedDays) {
                if (typeof(selectedDays) === "undefined" || selectedDays === null) {
                    selectedDays = [];
                }

                var arr = [];
                ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"].forEach(function(day) {
                    var dayNumber = arr.length + 1;
                    var isOn = (selectedDays.indexOf(dayNumber) !== -1);

                    arr.push(new kendo.data.ObservableObject({
                        day: day,
                        dayNumber: dayNumber,
                        shortName: day.charAt(0),
                        isOn: isOn,
                        triggerDay: function() {
                            this.set("isOn", !this.isOn);
                        }
                    }));
                });

                return arr;
            }

            function Repeater(repeatRule) {
                var scope = this;
                var eventList = {};
                var triggerEvent = function(name) {
                    var args = Array.prototype.slice.call(arguments).slice(1, arguments.length);
                    var eventCbList = eventList[name];
                    if (eventCbList) {
                        $.each(eventCbList, function() {
                            return this.apply(scope, args);
                        });
                    }
                };

                this.repeatPeriodsDS = new kendo.data.DataSource({
                    data: [{
                        text: "Weekly",
                        value: repeatPeriodEnum.weekly
                    }, {
                        text: "Daily",
                        value: repeatPeriodEnum.daily
                    }]
                });

                this.id = repeatRule.id;
                this.modifiedDate = repeatRule.modifiedDate;

                this.repeatPeriod = repeatRule.repeatPeriod;
                this.repeatInterval = repeatRule.repeatInterval;
                this.toDate = repeatRule.toDate ? new Date(repeatRule.toDate) : null;

                this.daysOfWeek = wrapDaysOfWeekToObservableObjects(repeatRule.repeatOn);

                this.shortFrequencyPeriodInfo = "";

                //*********************** PUBLIC API ***********************/
                this.getRepeatRule = function(blockStartTime, blockEndTime, defaultPeriodInMonths) {
                    // Note. Currently in UI we do not have options for specify repeater end time component (only date component)
                    // But API and repeater service use time component, so we have to add missed hours in code for proper API work.
                    // If we do not do this, and ignore time component, we can miss last block in series.

                    var repeatFromDate = new Date(blockStartTime); // In order to include first block in series we take date and time from blockStartTime.
                    var repeatToDate = new Date(blockEndTime); // In order to include last block in series we take date and time from blockEndTime.

                    if (this.toDate === null) {

                        // If user do not provided directly repeat rule end date we use default logic.
                        // We use block end date, and add default period (6 month if another value not provided)
                        var m = (typeof(defaultPeriodInMonths) === "undefined") ? 6 : defaultPeriodInMonths;

                        repeatToDate.setMonth(repeatToDate.getMonth() + m);
                    } else {

                        // If user provided repeat rule end date we use it.
                        var repeaterEndDate = new Date(this.toDate);
                        repeaterEndDate.setHours(0, 0, 0, 0);

                        var firstBlockEndDate = new Date(blockEndTime);
                        firstBlockEndDate.setHours(0, 0, 0, 0);

                        // Note.
                        // If firstBlockEndDate = repeaterEndDate we do not need to do anything.
                        // Block end time will be used as repeater end date.
                        //
                        // If repeaterEndDate > firstBlockEndDate we add time component (from blockEndTime) to repeater, otherwise last block in series could be missed.
                        // Example:
                        // first block start time:  01/01/2000 11:00
                        // first block end time:    01/02/2000 15:00
                        // repeater end date:       01/30/2000
                        // As result we set repeater end time to 01/30/2000 15:00
                        //
                        // If repeaterEndDate < firstBlockEndDate
                        // This is invalid business case, we keep repeatToDate without any changes because no block will be created at all.
                        // Example:
                        // first block start time:  01/20/2000 10:00
                        // first block end time:    01/20/2000 12:00
                        // repeater end date:       01/10/2000
                        // As result we set repeater end time to 01/10/2000 00:00

                        if (repeaterEndDate > firstBlockEndDate) {
                            var timeDiff = repeaterEndDate.getTime() - firstBlockEndDate.getTime();
                            var diffDays = Math.ceil(timeDiff / (1000 * 3600 * 24));

                            repeatToDate.setDate(repeatToDate.getDate() + diffDays);
                        } else if (repeaterEndDate < firstBlockEndDate) {
                            repeatToDate = repeaterEndDate;
                        }
                    }

                    var rule = {
                        id: this.id,
                        fromDate: $timeUtils.dateToString(repeatFromDate),
                        toDate: $timeUtils.dateToString(repeatToDate),
                        repeatInterval: this.repeatInterval,
                        repeatOn: this._getSelectedDaysNumbers(),
                        repeatPeriod: this.repeatPeriod,
                        modifiedDate: this.modifiedDate,

                        getFromDate: function() {
                            return repeatFromDate;
                        },

                        getToDate: function() {
                            return repeatToDate;
                        }
                    };

                    return rule;
                };

                this.getFrequencyPeriodInfo = function() {
                    var text = "";
                    var shortText = "";
                    switch (this.repeatPeriod) {
                        case repeatPeriodEnum.weekly:
                            if (this.repeatInterval === 1) {
                                shortText = "Week";
                                text = "Every week";
                            } else {
                                shortText = "Weeks";
                                text = "Every " + this.repeatInterval + " weeks";
                            }

                            var selectedDays = this._getSelectedDays().map(function(day) {
                                return day.day;
                            });

                            if (selectedDays.length > 0) {
                                text += " on " + selectedDays.join(", ");
                            }

                            break;
                        case repeatPeriodEnum.daily:
                            if (this.repeatInterval === 1) {
                                shortText = "Day";
                                text = "Every day";
                            } else {
                                shortText = "Days";
                                text = "Every " + this.repeatInterval + " days";
                            }
                            break;
                    }

                    this.set("shortFrequencyPeriodInfo", shortText);

                    return text;
                };

                //We need event subscription because we can not not use Kendo Observable in constructor.
                //And use var scope = this; scope.set("...", ...)
                this.on = function(eventName, cb) {
                    var eventCbList = eventList[eventName];
                    if (!eventCbList) {
                        eventCbList = [];
                    }
                    eventCbList.push(cb);
                    eventList[eventName] = eventCbList;
                };

                //*********************** MVVM BINDINGS ***********************/
                this.vm_onCloseClick = function(e) {
                    this.preventDefault(e);
                    triggerEvent(events.onRepeaterClose);
                };

                this.vm_isDayWeekSelectorVisible = function() {
                    return this.repeatPeriod === repeatPeriodEnum.weekly;
                };

                this.vm_isDaySelected = function() {
                    return !this.vm_isDayWeekSelectorVisible();
                };

                this.vm_onDayWeekSelectorClick = function() {
                    triggerEvent(events.onRepeaterChange);
                };


                this.vm_onRepeatPeriodChange = function() {
                    this.trigger("change", {
                        field: "vm_isDayWeekSelectorVisible"
                    });

                    this.trigger("change", {
                        field: "vm_isDaySelected"
                    });

                    triggerEvent(events.onRepeaterChange);
                };

                this.vm_onRepeatIntervalSpin = function(e) {
                    this.set("repeatInterval", e.sender.value());
                    triggerEvent(events.onRepeaterChange);
                };

                this.vm_onRepeatIntervalChange = function() {
                    triggerEvent(events.onRepeaterChange);

                    if (this.vm_repeatIntervalError) {
                        this.set("vm_repeatIntervalError", false);
                    }

                };

                this.vm_repeatIntervalError = false;

                this.vm_onToDateChange = function() {
                    triggerEvent(events.onDateChange);
                };


                //*********************** PRIVATE METHODS ***********************/
                this._getSelectedDays = function() {
                    return this.daysOfWeek.filter(function(day) {
                        return day.isOn;
                    });
                };

                this._getSelectedDaysNumbers = function() {
                    var selectedDays = [];

                    if (this.repeatPeriod === repeatPeriodEnum.weekly) {
                        selectedDays = this._getSelectedDays().map(function(day) {
                            return day.dayNumber;
                        });
                    }

                    return selectedDays;
                };
            }

            this.createRepeater = function(repeatRule) {
                var rule = $.extend(true, {}, emptyRepeatRule, repeatRule);

                return kendo.observable(new Repeater(rule));
            };
        }).singleton();
    snap.namespace("snap.admin")
        .use(["snap.common.ItemSelector"])
        .define("ItemSelector", function($itemSelector) {
            return $.extend({}, $itemSelector, {
                selector: function(opt) {
                    return $itemSelector.emptySelector(opt);
                },

                patientsSelector: function(opt) {
                    return $itemSelector.patientsSelector(opt);
                },

                emptySelector: function(opt) {
                    return $itemSelector.emptySelector(opt);
                },

                cliniciansSelector: function(opt) {
                    return $itemSelector.cliniciansSelector(opt);
                }
            });
        });
    snap.namespace("snap.admin").use([
        "snapNotification",
        "snap.service.availabilityBlockService",
        "snap.service.serviceTypesService",
        "snap.admin.ItemSelector",
        "snap.admin.schedule.Repeater",
        "snap.EventAggregator",
        "snap.common.schedule.ScheduleCommon",
        "snap.common.multiselectControl",
        "snap.admin.schedule.eventService",
        "snap.admin.schedule.TimeUtils"
    ]).define("AvailabilityBlockFactory", function($snapNotification, $availabilityBlockService, $serviceTypesService, $itemSelector,
        $repeater, $eventAggregator, $scheduleCommon, $multiselectControl, $eventService, $timeUtils) {
        var repeaterEvents = {
            onRepeaterChange: "onRepeaterChange",
            onRepeaterClose: "onRepeaterClose",
            onDateChange: "onDateChange"
        };

        var events = {
            serviceTypesLoaded: "serviceTypesSource_loaded",
            serviceTypeChanged: "serviceType_changed"
        };

        var phoneTypeEnum = {
            home: 0,
            mobile: 1,
            other: 3
        };

        var repeatPeriodEnum = {
            daily: 0,
            weekly: 1
        };

        var messages = {
            endDateAfterStart: "End date must be after the start date.",
            emptyStartDate: "Start date is required.",
            emptyEndDate: "End date is required."
        };

        var encounterTypeCodes = snap.enums.EncounterTypeCode;

        var start = new Date();
        start.setHours(12, 0, 0, 0);

        var end = new Date();
        end.setHours(12, 15, 0, 0);

        var emptyAvailabilityBlock = {
            id: 0,
            start: start,
            end: end,
            onDemandEnabled: snap.hospitalSettings.onDemand,
            onDemandEnabledOrRO: snap.hospitalSettings.onDemand,
            selfApptEnabled: snap.hospitalSettings.providerSearch,
            selfApptEnabledOrRO: snap.hospitalSettings.providerSearch,
            allowOnDemandAppt: false,
            allowSelfAppt: false,
            allowProviderAppt: false,
            isAvailable: true,
            isAllDay: false,
            optimizationTypeCodeId: 1,
            availabilityBlockRuleId: null,
            clinician: null,
            rule: null
        };

        var emptyAppointment = {
            id: 0,
            start: start,
            end: end,
            isAllDay: false,
            waiveFee: false
        };

        var emptyEncounterDocument = {
            id: 0,
            start: start,
            end: end
        };

        var defaultDisplayOptions = {
            forceReadOnly: false
        };

        var serviceTypes, timeZones;

        var getServiceTypesDataSource = function(isReadonly, selectedService) {
            return new kendo.data.DataSource({

                transport: {
                    read: function(options) {
                        if (isReadonly) {
                            options.success([selectedService]);
                        } else {
                            var serviceTypesPromise = typeof(serviceTypes) === "undefined" ? $serviceTypesService.get(snap.hospitalSession.hospitalId) :
                                $.Deferred().resolve(serviceTypes);
                            serviceTypesPromise.then(function(response) {
                                serviceTypes = response;
                                response = response.filter(function(item) {
                                    return item.appointmentType === $scheduleCommon.appointmentTypeCode.clinicianScheduled ||
                                        item.serviceTypeId === selectedService.serviceTypeId;
                                });
                                options.success(response);
                            }, function(error) {
                                $snapNotification.error("Failed to load service types");
                                options.error(error);
                            });
                        }
                    }
                }
            });
        };

        var getTimeZones = function( /*nameFilter*/ ) {
            var dfd = $.Deferred();
            //var filter = nameFilter.toLowerCase();
            var timeZonesPromise = typeof(timeZones) === "undefined" ? loadTimeZones() : $.Deferred().resolve(timeZones);
            timeZonesPromise.done(function(timeZonesResponse) {
                /*var data = timeZonesResponse.filter(function (item, index) {
                    if ($.trim(filter) === "") {
                        return true;
                    }
                    if (!item.text.toLowerCase().includes(filter)) {
                        if (!item.name.toLowerCase().includes(filter)) {
                            return false;
                        }
                    }
                    var firstIndex = 0;
                    timeZonesResponse.find(function (innerItem, innerIndex) {
                        if (innerItem.text == item.text) {
                            firstIndex = innerIndex;
                            return true;
                        } else {
                            return false;
                        }
                    });
                    return item.text && firstIndex == index;
                });
                dfd.resolve(data);*/
                dfd.resolve(timeZonesResponse);
            });
            return dfd.promise();
        };

        var timeZoneDataSource = new kendo.data.DataSource({
            serverFiltering: true,
            transport: {
                read: function(options) {
                    //var filter = options.data.filter ? options.data.filter.filters[0].value : "";
                    getTimeZones().done(function(data) {
                        options.success(data);
                    });
                }
            }
        });

        var loadTimeZones = function() {
            var dfd = $.Deferred();
            $availabilityBlockService.getTimeZones().then(function(response) {
                var data = response.data.map(function(item) {
                    return {
                        id: item.id,
                        text: item.abbreviation,
                        name: item.name
                    };
                });
                data = data.sort(function(a, b) {
                    if (a.text < b.text) {
                        return -1;
                    }
                    return 1;
                });
                timeZones = data;
                dfd.resolve(data);
            }, function() {
                $snapNotification.error("Failed to load timezones");
                dfd.resolve([]);
            });
            return dfd.promise();
        };

        $eventService.setScope($scheduleCommon.blockPermissions.allowProviderAppt);

        function SchedulerDialog(opt) {
            var scope = this;
            this.isRuleAvailable = true;

            this.id = opt.id;
            this.start = opt.start;
            this.vm_startDateError = false;
            this.end = opt.end;
            this.vm_endDateError = false;

            // this properties contain start and end time in user's default timezone.
            this.startInCurrentUserTimezone = opt.startInCurrentUserTimezone || new Date(opt.start);
            this.endInCurrentUserTimezone = opt.endInCurrentUserTimezone || new Date(opt.end);

            // This two fields necessary in order to track end time changes. Ticket #6020
            // We need this fields because kendo datepicker do not provide information ("old date" and "new date" ) on date change event, so you cannot calculate time difference.
            var copyOfStartDate = new Date(opt.start);
            var copyOfEndDate = new Date(opt.end);

            // This two fields necessary in order ot track previous value when you change "All Day" checkbox.
            var isAllDayTriggerStartDate = null;
            var isAllDayTriggerEndDate = null;

            this.isAllDay = false;
            this.repeater = $repeater.createRepeater(opt.rule);
            this.frequencyPeriodInfo = this.repeater.getFrequencyPeriodInfo();

            this.isRepeat = opt.rule ? true : false; //Indicate whether this is a single event or it happens frequently.

            this.isLoading = false;
            this.isError = false;
            this.isDisabled = false;
            this.showFrequencyDetails = false;
            this.timeZoneId = snap.profileSession.timeZoneId; // for now display appointment in current user's timezone
            this.timeZoneName = snap.profileSession.timeZone;
            this.selectedTimeZone = null;

            this.preventDefault = function(e) {
                if (e) {
                    e.preventDefault();
                }
            };

            if (this._setOptionsForConcreteEventType) {
                this._setOptionsForConcreteEventType(opt);
            }
            this.vm_userTrayHeaderText = function() {
                return "Who is this availability for?";
            };
            this.vm_isNotError = function() {
                return !this.isError;
            };
            this.vm_isLoading = false;

            this.getOptions = function() {
                var opt = {
                    id: this.id,
                    start: new Date(this.start),
                    end: new Date(this.end),
                    isAllDay: this.isAllDay
                };

                if (this._getOptionsForConcreteEventType) {
                    opt = $.extend(true, opt, this._getOptionsForConcreteEventType());
                }

                return opt;
            };

            this.vm_dayWeekSelectorError = false;

            //*********************** PUBLIC API ***********************/
            this.setInitialFocus = function() {
                $(".directory__opener").first().focus();
            };
            this.load = function(clinicianIds, userType) {
                var dfd = $.Deferred();
                scope = this;

                this.set("vm_isLoading", true);
                this.set("userType", userType);
                if (this.isRuleAvailable) {
                    if (this.repeater.id) {
                        this.set("isRepeat", true);
                    } else {
                        this.set("isRepeat", false);
                    }
                } else {
                    this.set("isRepeat", false);
                }

                //we need to keep this here because kendo observable create new object not extend current one.
                this.repeater.on(repeaterEvents.onRepeaterChange, function() {
                    scope.set("frequencyPeriodInfo", scope.repeater.getFrequencyPeriodInfo());

                    scope.set("vm_dayWeekSelectorError", false);
                    scope.set("vm_repeatPeriodError", false);
                });

                this.repeater.on(repeaterEvents.onRepeaterClose, function() {
                    scope._showFrequencyDetails(false);
                });

                this.repeater.on(repeaterEvents.onDateChange, function() {
                    scope.set("vm_toDateError", false);
                });

                if (this._loadDetails) {
                    this._loadDetails(userType).done(function() {
                        subscribe(scope);
                        // 1 second timeout to prevent css issues
                        // so that all styles will apply
                        setTimeout(function() {
                            scope.set("vm_isLoading", false);
                            scope.setInitialFocus();
                        }, 1000);
                        dfd.resolve();
                    });
                } else {
                    subscribe(this);
                    dfd.resolve();
                }

                function subscribe(that) {
                    if (!($eventAggregator.hasSubscriptions("itemSelector_onProfileClick"))) {
                        $eventAggregator.subscriber("itemSelector_onProfileClick", function(profile) {
                            $snapNotification.confirmationWithCallbacks("Viewing this profile will exit the scheduler. Do you want to proceed?", function() {
                                if (that.userType === $scheduleCommon.userType.admin) {
                                    if (profile.personType === $itemSelector.personType.patient) {
                                        goToPatietProfile("/Admin/Patient", profile);
                                    } else if (profile.personType === $itemSelector.personType.clinician) {
                                        snap.StaffUserID = profile.id;
                                        sessionStorage.setItem('snap_staffViewEditProfile', snap.StaffUserID);
                                        location.href = "/Admin/StaffAccount";
                                    }
                                } else if (that.userType === $scheduleCommon.userType.clinician) {
                                    if (profile.personType === $itemSelector.personType.patient) {
                                        goToPatietProfile("/Physician/PatientFile", profile);
                                    } else {
                                        if (snap.hasAnyPermission(snap.security.edit_staff_accounts, snap.security.edit_public_facing_profile_details_self)) {
                                            location.href = "/Physician/EditPhysicianProfile";
                                        } else {
                                            $snapNotification.info("You don't have permission to edit your profile.");
                                        }
                                    }
                                }
                            });

                            function goToPatietProfile(url, profile) {
                                sessionStorage.setItem("snap_patientId_ref", profile.id);
                                snap.submitForm({
                                    url: url,
                                    method: "POST"
                                }, {
                                    patientId: profile.id,
                                    token: snap.userSession.token
                                });
                            }
                        });
                    }
                }

                return dfd.promise();
            };

            this.save = function() {
                return this.saveAll(); //saveAll - Implemented in concrete dialogs Appointment/AvailabilityBlock.
            };

            this.remove = function() {
                //If necessary here we can implement some general logic like in save method.

                return this.removeAll(); //removeAll - Implemented in concrete dialogs Appointment/AvailabilityBlock.
            };

            //ToDo: we need to keep here only UI specific validation. Common validation should go to eventService.js
            this.validate = function() {
                var errorList = [];

                if (this.start === null) {
                    errorList.push(messages.emptyStartDate);
                    this.set("vm_startDateError", true);
                    this.set("vm_isSelectedStartDate", false);
                }

                if (this.end === null) {
                    errorList.push(messages.emptyEndDate);
                    this.set("vm_endDateError", true);
                    this.set("vm_isSelectedEndDate", false);
                }

                if (this.end <= this.start) {
                    errorList.push(messages.endDateAfterStart);
                    this.set("vm_endDateError", true);
                    this.set("vm_isSelectedEndDate", false);
                }

                if (this.isRepeat) {
                    var repeatRule = this.repeater.getRepeatRule(this.startInCurrentUserTimezone, this.endInCurrentUserTimezone);

                    if ($("#dialogbox__end-repeat").val().trim() !== "" && this.repeater.toDate === null) {
                        errorList.push("Invalid End Repeat date format");
                        this.set("vm_toDateError", true);
                    }

                    if (repeatRule.repeatPeriod !== repeatPeriodEnum.weekly && repeatRule.repeatPeriod !== repeatPeriodEnum.daily) {
                        errorList.push("Invalid repeat period.");
                        this.set("vm_repeatPeriodError", true);
                    }

                    if (repeatRule.repeatInterval <= 0) {
                        errorList.push("Repeat interval must be 1 or more.");
                        this.set("vm_repeatIntervalError", true);
                    }

                    if (repeatRule.repeatPeriod === repeatPeriodEnum.weekly && repeatRule.repeatOn.length === 0) {
                        errorList.push("Select at least one day to repeat.");
                        this.set("vm_dayWeekSelectorError", true);
                    }

                    var fromDate = $timeUtils.dateFromSnapDateString(repeatRule.fromDate);
                    var toDate = $timeUtils.dateFromSnapDateString(repeatRule.toDate);

                    if (this.end !== null && this.end > toDate) {
                        errorList.push("Repeat end date should be after the first block end date.");
                        this.set("vm_toDateError", true);
                    } else if (toDate <= fromDate) {
                        errorList.push("Repeat end date should be after the start date.");
                        this.set("vm_toDateError", true);
                    }
                }

                return errorList.concat(this._validateDetails()); //validate details implemented in concrete dialogs Appointment/AvailabilityBlock.
            };

            this.validateRepeatRule = function() {
                var notifications = [];
                var repeatRule = this.repeater.getRepeatRule(this.startInCurrentUserTimezone, this.endInCurrentUserTimezone);
                var duration = this.endInCurrentUserTimezone - this.startInCurrentUserTimezone;
                if (repeatRule.repeatPeriod === repeatPeriodEnum.weekly) {
                    var eventsCount = 0,
                        day = new Date(this.endInCurrentUserTimezone),
                        intervalCounter = repeatRule.repeatInterval,
                        repeatDaysOfWeek = repeatRule.repeatOn,
                        expectedEventsCount = repeatDaysOfWeek.length;

                    while (day <= repeatRule.getToDate()) {
                        var eventStart = new Date(day.getTime() - duration);
                        if (repeatDaysOfWeek.indexOf(eventStart.getDay() + 1) >= 0 && intervalCounter % repeatRule.repeatInterval === 0) {
                            eventsCount++;
                        }
                        day = $timeUtils.addDays(day, 1);
                        if (day.getDay() === 0) { //getDay() method returns the day of the week (from 0 to 6). Sunday is 0
                            intervalCounter++;
                        }
                    }

                    if (eventsCount < expectedEventsCount) {
                        notifications.push("Please note: Repeat days outside the specified time range have been ignored.");
                    }
                }
                return notifications;
            };

            this.validateTime = function() {
                var errorList = [];
                var dfd = $.Deferred();
                var that = this;
                $availabilityBlockService.getUserCurrentTime().done(function(response) {
                    var currentUserTime = $timeUtils.dateFromSnapDateString(response.data[0]);

                    errorList = that._validateTimeDetails(currentUserTime);

                    var opt = that.getOptions();
                    if (errorList.length === 0 && (opt.end.getTime() - opt.start.getTime()) > 86400000) {
                        errorList.push("Block duration should be less than 24 hours.");
                        that.set("vm_endDateError", true);
                        that.set("vm_isSelectedEndDate", false);
                    }

                    dfd.resolve(errorList);
                });
                return dfd.promise();
            };


            //*********************** MVVM BINDINGS ***********************/

            this.vm_isPatientSelectError = false;

            this.vm_isProviderSelectError = false;

            this.vm_serviceTypeError = false;

            this.vm_repeatPeriodError = false;

            this.vm_timeZoneError = false;

            this.vm_disableSelectError = function(personType) {
                if (this.vm_isPatientSelectError || this.vm_isProviderSelectError) {
                    if (personType == $itemSelector.personType.patient) {
                        this.set("vm_isPatientSelectError", false);
                    } else {
                        this.set("vm_isProviderSelectError", false);
                    }
                }
                this.set("vm_canShowTimeOffsets", !this.vm_isPatientSelectError && !this.vm_isProviderSelectError);
            };

            this.vm_onStartDatePartChange = function() {
                if (this.start) {
                    // fix time part resetting when changing date part
                    this.start.setHours(copyOfStartDate.getHours());
                    this.start.setMinutes(copyOfStartDate.getMinutes());
                    this.trigger("change", { field: "start" });
                }
                this.vm_onStartDateChange();
            };
            this.vm_onStartDateChange = function() {
                this._setStartDate(this.start);
                this._updateSelectorTime();
                this._onDataChange();
            };
            this.vm_onEndDatePartChange = function() {
                if (this.end) {
                    // fix time part resetting when changing date part
                    this.end.setHours(copyOfEndDate.getHours());
                    this.end.setMinutes(copyOfEndDate.getMinutes());
                    this.trigger("change", { field: "end" });
                }
                this.vm_onEndDateChange();
            };
            this.vm_onEndDateChange = function() {
                this._setEndDate(this.end);
                this._updateSelectorTime(true);
                this._onDataChange();
            };
            this.vm_onWaiveFeeChange = function() {
                this._onDataChange();
            };
            this.vm_serviceTypeActive = false;
            this.vm_onChangeServiceType = function() {
                this.set("vm_serviceTypeError", false);
                this.set("vm_serviceTypeActive", this.serviceTypeId !== null);
                $eventAggregator.published(events.serviceTypeChanged);
                this._onDataChange();
            };
            this.vm_timeZoneActive = false;
            this.vm_onChangeTimeZone = function() {
                var that = this;
                this.set("vm_timeZoneError", false);
                this.set("vm_timeZoneActive", this.timeZoneId !== null);
                if (this.timeZoneId !== null) {
                    this.timeZoneName = this.timeZoneDs.data().find(function(item) {
                        return item.id == that.timeZoneId;
                    }).name;
                }
                /*if (this.selectedTimeZone === null || !this.selectedTimeZone.id) {
                    this.set("vm_timeZoneError", true);
                } else {
                    this.set("vm_timeZoneError", false);
                    this.timeZoneId = this.selectedTimeZone.id;
                }
                this.set("vm_timeZoneActive", this.selectedTimeZone !== null);*/
                this._onDataChange();
                this._updateSelectorTime();
            };

            this.vm_isNew = function() {
                return this.id === 0;
            };

            this.vm_toDateError = false;

            // We do not use standard kendo "isAllDay" option because our scheduler do not have "All Day" section.
            // Instead we have custom "All Day" checkbox, it value is true when block start from 00:00 and end in 23:59.
            // See 'vm_onIsAllDayChange' for more details.
            this.vm_isAllDay = function() {
                return isAllDayInterval(this.start, this.end);
            };

            this.vm_onIsAllDayChange = function() {
                if (!this.vm_isAllDay()) {
                    // Backup current "start" and "end" dates, if user uncheck "All Day" checkbox this values will be restored as "start" and "end" dates.
                    isAllDayTriggerStartDate = new Date(this.start);
                    isAllDayTriggerEndDate = new Date(this.end);

                    var dayBegin = new Date(this.start);
                    dayBegin.setHours(0, 0, 0, 0); // Set "start" date to 00:00:00.

                    var dayEnd = new Date(this.start);
                    dayEnd.setHours(23, 59, 0, 0); // Set "end" date to 23:59:00. We ignore seconds because you can not set them from UI.

                    this._setStartDate(dayBegin);
                    this._setEndDate(dayEnd);
                } else {
                    // If there is no isAllDayTriggerStartDate (such scenario happens when you open event and "All Day" checkbox already checked)
                    // we automatically set it to default time for this event type (by default 12:00PM 240 min for AB, and 15 min for Appt).
                    if (isAllDayTriggerStartDate === null || isAllDayTriggerEndDate === null) {
                        isAllDayTriggerStartDate = this._getDefaultStartDate();
                        isAllDayTriggerEndDate = this._getDefaultEndDate();
                    }

                    // Restore "start" and "end" dates from backup.
                    this._setStartDate(isAllDayTriggerStartDate);
                    this._setEndDate(isAllDayTriggerEndDate);

                    // We do not need this fields once "All Day" checkbox unchecked.
                    isAllDayTriggerEndDate = null;
                    isAllDayTriggerEndDate = null;
                }
            };

            this.vm_getFrequencyDetailsToogleButtonText = function() {
                return this.showFrequencyDetails ? "Done" : "Edit";
            };

            this.vm_onRepeatChange = function() {
                this._showFrequencyDetails(this.isRepeat);
                var elem = $('#dialogbox-master__left-container');

                this._onDataChange();

                setTimeout(function() {
                    elem.scrollTop(817);
                }, 300);
            };

            this.vm_toogleFrequencyDetails = function(e) {
                this.preventDefault(e);
                this._showFrequencyDetails(!this.showFrequencyDetails);

                var elem = $('#dialogbox-master__left-container');

                setTimeout(function() {
                    elem.animate({ scrollTop: 600 }, 300);
                }, 300);
            };

            this._convertInputTimeToCurrentUserTimezone = function() {
                var dfd = $.Deferred();
                var that = this;
                this.startInCurrentUserTimezone = new Date(this.start);
                this.endInCurrentUserTimezone = new Date(this.end);

                if (this.timeZoneId && this.timeZoneId !== snap.profileSession.timeZoneId) {
                    // need to convert time for searching blocks
                    var duration = this.endInCurrentUserTimezone - this.startInCurrentUserTimezone;
                    var opt = {
                        dateTime: $timeUtils.dateToString(this.startInCurrentUserTimezone),
                        sourceTimeZoneId: this.timeZoneId,
                        targetTimeZoneId: snap.profileSession.timeZoneId
                    };
                    $availabilityBlockService.convertTime(opt).then(function(convertedTime) {
                        that.startInCurrentUserTimezone = $timeUtils.dateFromSnapDateString(convertedTime.convertedDateTime);
                        that.endInCurrentUserTimezone = new Date(that.startInCurrentUserTimezone);
                        that.endInCurrentUserTimezone.setTime(that.endInCurrentUserTimezone.getTime() + duration);
                        dfd.resolve();
                    }, function(error) {
                        dfd.reject(error);
                    });
                } else {
                    dfd.resolve();
                }

                return dfd.promise();
            };

            this._saveAction = function() {
                var that = this;
                this.set("isError", false);

                $snapNotification.hideAllConfirmations();

                if (this._isAffectSeries()) {
                    var message = "Are you sure that you want to save this series of " + this._typeName + "s?";
                    var notifications = this.validateRepeatRule();
                    if (notifications.length) {
                        $snapNotification.info(notifications.join("<br\>"));
                        window.setTimeout(function() {
                            $snapNotification.confirmationWithCallbacks(message, function() {
                                saveAction();
                            });
                        }, 1000);
                    } else {
                        $snapNotification.confirmationWithCallbacks(message, function() {
                            saveAction();
                        });
                    }
                } else {
                    saveAction();
                }


                function saveActionInternal(dfd) {
                    that.save().done(function(result) {
                        var isSeries = that._isAffectSeries();
                        var isNew = that.vm_isNew();
                        if (isSeries) {
                            that._showFrequencyDetails(false);
                        }
                        if (result.total || result.data.length) {
                            var message = that._typeName + (isSeries ? "s" : "") + (isNew ? " created " : " updated ") + "successfully";
                            $snapNotification.success(message);
                            // tony.y for #9618
                            var opts = that.getOptions();
                            opts.clinician.clinicianId = 0;
                            $eventAggregator.published(that._onSubmitClickEvent, opts);
                        } else
                            $eventAggregator.published(that._onSubmitClickEvent, that.getOptions()); //_onSubmitClickEvent - Implemented in concrete dialogs Appointment/AvailabilityBlock.

                        dfd.resolve();
                    }).fail(function(error) {
                        if (error) {
                            $snapNotification.error(error);
                        }
                        dfd.reject();
                    });
                }

                function saveAction() {
                    that.set("isLoading", true);
                    that.set("isError", false);

                    var dfd = $.Deferred();
                    dfd.done(function() {
                        that.set("isError", false);
                    }).fail(function() {
                        that.set("isError", true);
                    }).always(function() {
                        that.set("isLoading", false);
                    });

                    that.validateTime().done(function(timeErrors) {
                        if (timeErrors.length === 0) {
                            if (that.timeZoneId !== that.cliniciansSelector.selectedItem.timeZoneId) {
                                $snapNotification.confirmationWithCallbacks(
                                    ["Selected provider is in ", that.cliniciansSelector.selectedItem.timeZoneName, " time zone, and your ", that._type === $scheduleCommon.eventType.appointment ? "Appointment" : "Availability Block", " time is set for ", that.timeZoneName, " time zone. Do you want to proceed?"].join(""),
                                    function() {
                                        saveActionInternal(dfd);
                                    },
                                    function() {
                                        dfd.resolve();
                                    });
                            } else {
                                saveActionInternal(dfd);
                            }

                        } else {
                            $snapNotification.error(timeErrors.join("<br\>"));
                            dfd.reject();
                        }
                    }).fail(function() {
                        $snapNotification.error("Cannot validate time.");
                        dfd.reject();
                    });
                }
            };

            this.vm_onSubmitClick = function(e) {
                var that = this;

                if (this.isLoading) {
                    this.preventDefault(e);
                    return false;
                }

                this._convertInputTimeToCurrentUserTimezone().done(function() {
                    var errors = that.validate();
                    if (errors.length === 0) {
                        that._saveAction();
                    } else {
                        $snapNotification.error(errors.join("<br\>"));
                        that.set("isError", true);
                    }
                });

                return true;
            };

            this.vm_onRescheduleClick = function() {
                this.set("isLoading", true);
                $eventAggregator.published(this._onRescheduleEvent, this);
            };

            this.vm_onCloseClick = function(e) {
                $eventAggregator.published(this._onCloseClickEvent, this); //_onCloseClickEvent - Implemented in concrete dialogs Appointment/AvailabilityBlock.

                $snapNotification.hideAllConfirmations();

                this.preventDefault(e);
            };

            this.vm_onRemoveClick = function() {
                var that = this;
                $snapNotification.hideAllConfirmations();
                $snapNotification.confirmationWithCallbacks(that._removeCurrentEventMessage, function() {

                    that.set("isLoading", true);
                    that.set("vm_appointmentChanged", true);
                    that.trigger("change", { field: "vm_isNotError" });

                    that.remove().done(function() {
                        $eventAggregator.published(that._onRemoveClickEvent, that); //_onRemoveClickEvent - Implemented in concrete dialogs Appointment/AvailabilityBlock.
                        $snapNotification.success(that._removedSuccesfullyMessage);
                    }).fail(function(error) {
                        $snapNotification.error(error);
                        that.set("isError", true);
                    }).always(function() {
                        that.set("isLoading", false);
                    });
                });
            };

            //*********************** PRIVATE API ***********************/
            this._showFrequencyDetails = function(showFrequencyDetails) {
                this.set("showFrequencyDetails", showFrequencyDetails);
                this.trigger("change", {
                    field: "showFrequencyDetails"
                });
                this.trigger("change", {
                    field: "vm_getFrequencyDetailsToogleButtonText"
                });
            };

            this._isAffectSeries = function() {
                return this.isRuleAvailable && this.isRepeat;
            };

            this._getDefaultStartDate = function() {
                var startDate = new Date(this.start);
                startDate.setHours(12, 0, 0, 0);

                return startDate;
            };

            this._getDefaultEndDate = function() {
                var endDate = new Date(this._getDefaultStartDate()),
                    settingName = this._defaultIntervalSetting, // implemented in concrete event type
                    defaultInterval = this._defaultInterval; // implemented in concrete event type

                if (snap.hospitalSettings && snap.hospitalSettings[settingName]) {
                    endDate.setMinutes(endDate.getMinutes() + parseInt(snap.hospitalSettings[settingName]));
                } else {
                    endDate.setMinutes(endDate.getMinutes() + defaultInterval);
                }

                return endDate;
            };

            this._setStartDate = function(newStartDate) {
                this._startErrorDueToEnd = false;
                if (newStartDate === null) {
                    $snapNotification.error(messages.emptyStartDate);
                    this.set("start", new Date(copyOfStartDate));
                    if (this.start === null) {
                        this.set("vm_startDateError", true);
                        this.set("vm_isSelectedStartDate", false);
                    }
                } else {
                    this.set("start", newStartDate);
                    this.set("vm_isSelectedStartDate", true);
                    this.set("vm_startDateError", false);

                    //claculated time diff with previous start date value.
                    var timeDiff = Math.abs(copyOfStartDate.getTime() - this.end.getTime());
                    this.set("end", new Date(this.start.getTime() + timeDiff));
                    this.set("vm_isSelectedEndDate", true);
                    this.set("vm_endDateError", false);

                    //remembered copy of 'start' and 'end' date to avoid wrong autofilling.
                    copyOfStartDate = new Date(this.start);
                    copyOfEndDate = new Date(this.end);
                }

                this.trigger("change", { field: "vm_isAllDay" });
            };

            this._setEndDate = function(newEndDate) {
                if (newEndDate === null) {
                    $snapNotification.error(messages.emptyEndDate);
                    this.set("end", new Date(copyOfEndDate));
                    if (this.end === null) {
                        this.set("vm_endDateError", true);
                        this.set("vm_isSelectedEndDate", false);
                    }
                } else if (newEndDate < this.start) {
                    $snapNotification.error(messages.endDateAfterStart);
                    this.set("end", new Date(copyOfEndDate));
                    if (this.end < this.start) {
                        this.set("vm_endDateError", true);
                        this.set("vm_isSelectedEndDate", false);
                    }
                } else {
                    this.set("end", newEndDate);
                    copyOfEndDate = new Date(newEndDate);

                    this.set("vm_isSelectedEndDate", true);
                    this.set("vm_endDateError", false);

                    if (this._startErrorDueToEnd) {
                        this.set("vm_isSelectedStartDate", true);
                        this.set("vm_startDateError", false);
                        this._startErrorDueToEnd = false;
                    }
                }

                this.trigger("change", { field: "vm_isAllDay" });
            };

            function isAllDayInterval(start, end) {
                // Check if event starts at the beginning of day
                if (start.getHours() === 0 && start.getMinutes() === 0) {
                    // If event starts at the beginning of day and has 23:59 hours duration, we mark such event as "All Day".
                    // We check not exact time but 1 minute interval from 23:59:00 to 24:00:00 in order to support old events.
                    // This is because previously we did not had "All day" option and there was cases when block time was set to 23:59:00 or 23:59:59 for example.
                    var interval = (end.getTime() - start.getTime());
                    return 86340000 <= interval && interval <= 86400000;
                }

                return false;
            }
        }


        function AvailabilityBlock(opt, displayOpt) {
            var defaultClinician = {
                id: null,
                name: "Select a Provider",
                imageSource: "images/Patient-Male.gif",
                info: "For this availability"
            };

            this._requestTime = opt.abRequestTime;
            this._type = $scheduleCommon.eventType.availabilityBlock;
            this._typeName = "Availability Block";
            this._onSubmitClickEvent = "ab_onSubmitClick";
            this._onCloseClickEvent = "ab_onCloseClick";
            this._onRemoveClickEvent = "ab_onRemoveClick";
            this._onDblClickEvent = "ab_onDblClick";
            this.vm_isReschedulable = false;

            this._defaultInterval = 240;
            this._defaultIntervalSetting = "defaultAvailabilityBlockDuration";

            this._removeCurrentEventMessage = "Are you sure that you want to cancel this Availability Block?";
            this._removedSuccesfullyMessage = "The Availability Block was removed successfully";

            this.cliniciansSelector = $itemSelector.cliniciansSelector({
                defaultItem: defaultClinician
            });

            this._setOptionsForConcreteEventType = function(opt) {
                this.onDemandEnabled = !opt.onDemandEnabled;
                this.allowOnDemandAppt = opt.allowOnDemandAppt;
                this.selfApptEnabled = !opt.selfApptEnabled;
                this.allowSelfAppt = opt.allowSelfAppt;
                this.allowProviderAppt = opt.allowProviderAppt;
                this.isAvailable = opt.isAvailable;
                this.optimizationTypeCodeId = opt.optimizationTypeCodeId;
                this.availabilityBlockRuleId = opt.availabilityBlockRuleId;
                this.clinician = opt.clinician;
                this.onDemandEnabledOrRO = !opt.onDemandEnabled || this.isReadOnly;
                this.selfApptEnabledOrRO = !opt.selfApptEnabled || this.isReadonly;
                this.title = ""; //Dummy field, necessary for Agenda View.

                this.isLocked = false; //Admin owned
                this.isPrivate = false; //Clinician owned
                this.isProtectedBlock = false;

                if (opt.clinician) {
                    this.isLocked = opt.clinician.locked;
                    this.isPrivate = opt.clinician.private;
                    this.isProtectedBlock = this.isLocked || this.isPrivate;

                    var that = this;
                    $availabilityBlockService.getClinicianProfile(snap.hospitalSession.hospitalId, opt.clinician.clinicianId).done(function(response) {
                        var person = response.data[0].person;
                        var item = {
                            id: response.data[0].userId,
                            personId: person.id,
                            name: $scheduleCommon.getFullName(person),
                            imageSource: person.photoUrl,
                            info: $scheduleCommon.getPhoneNumber(person),
                            data: response.data[0],
                            personType: $itemSelector.personType.clinician
                        };
                        that.cliniciansSelector.selectItem(item);
                        that.cliniciansSelector.updateEventTime(that.start, that.end, that.timeZoneId, false);
                    }).fail(function() {
                        $snapNotification.error("Provider profile was not found");
                    });

                }
            };

            this._getOptionsForConcreteEventType = function() {
                var opt = {
                    allowOnDemandAppt: this.allowOnDemandAppt,
                    allowProviderAppt: this.allowProviderAppt,
                    allowSelfAppt: this.allowSelfAppt,
                    isAvailable: this.isAvailable,
                    optimizationTypeCodeId: this.optimizationTypeCodeId,
                    rule: null,
                    clinician: null
                };

                var clinician = this.cliniciansSelector.getSelectedItem();
                if (clinician) {
                    opt.clinician = {
                        availabilityBlockId: this.id,
                        clinicianId: clinician.id,
                        locked: this.isLocked,
                        private: this.isPrivate
                    };
                }

                if (this._isAffectSeries()) {
                    opt.rule = this.repeater.getRepeatRule(this.startInCurrentUserTimezone, this.endInCurrentUserTimezone);
                }

                return opt;
            };

            this._updateSelectorTime = function(useCahedValue) {
                this.cliniciansSelector.updateEventTime(this.start, this.end, this.timeZoneId, useCahedValue);
            };


            //****************** Call BASE constructor ********************
            SchedulerDialog.call(this, opt);

            //******************************** On dialog show **********************************/
            this._loadDetails = function(userType) {
                var dfd = $.Deferred();
                this.cliniciansSelector.set("isSelectorLocked", userType === $scheduleCommon.userType.clinician);
                dfd.resolve();
                return dfd.promise();
            };

            //********************* Availability Block methods *************************/
            this.isUnavailable = function() {
                return !this.isAvailable;
            };
            //ToDo: implement allowOnDemandAppt allowSelfAppt allowProviderAppt isAvailable trigger.
            this.onAvailableChange = function() {
                this.isAvailable = !this.isAvailable;
                this.trigger("change", {
                    field: "isUnavailable"
                });
                if (!this.isAvailable) {
                    this.set("allowOnDemandAppt", false);
                    this.set("allowSelfAppt", false);
                    this.set("allowProviderAppt", false);

                }
            };
            this.onApptOptionChange = function() {
                if (this.allowOnDemandAppt || this.allowSelfAppt || this.allowProviderAppt) {
                    this.set("isAvailable", true);
                    this.trigger("change", {
                        field: "isUnavailable"
                    });
                }
            };

            this.onIsProtectedBlockChange = function() {
                switch (this.userType) {
                    case $scheduleCommon.userType.admin:
                        this.set("isLocked", this.isProtectedBlock);
                        break;
                    case $scheduleCommon.userType.clinician:
                        this.set("isPrivate", this.isProtectedBlock);
                        break;
                }
            };

            this.saveAll = function() {
                return $eventService.saveAvailabilityBlock(this.getOptions(), this._requestTime);
            };

            this.removeAll = function() {
                return $eventService.cancelAvailabilityBlock(this.getOptions());
            };

            this._validateDetails = function() {
                var errorList = [];

                if (!this.allowOnDemandAppt && !this.allowSelfAppt && !this.allowProviderAppt && !this.isUnavailable()) {
                    errorList.push("Select at least one service option.");
                }

                if (this.cliniciansSelector.getSelectedItem() === null) {
                    errorList.push("Select a provider.");
                    this.set("vm_isProviderSelectError", true);
                }

                return errorList;
            };

            this._onDataChange = function() {
                // no action
            };

            this._validateTimeDetails = function(currentUserTime) {
                var errorList = [];
                if (this.end < currentUserTime) {
                    // end time of updating availability block should be in the future
                    errorList.push("Block end time should not be in the past.");
                    this.set("vm_endDateError", true);
                    this.set("vm_isSelectedEndDate", false);

                    this._startErrorDueToEnd = true;
                    this.set("vm_startDateError", true);
                    this.set("vm_isSelectedStartDate", false);
                }
                return errorList;
            };
        }

        function ConsultationDialog(opt, displayOpt) {
            var scope = this;
            var defaultClinician = {
                id: null,
                name: "Select a provider",
                imageSource: "images/Patient-Male.gif",
                info: "For this appointment"
            };

            var defaultPatient = {
                id: null,
                name: "Select a Patient",
                imageSource: "images/Patient-Male.gif",
                info: "For this appointment"
            };

            var validatePhoneNumber = function(phoneNumber) {
                //var phoneRegex = /^[\-\+]?(\s?[-()]?\s?[0-9]{1}){2,20}$/;
                var phoneRegex = /^[\-\+]?\s?([0-9]{1,2})?(\s?[-(]?\s?[0-9]{2,3}\s?[-)]?)?(\s?-?\s?[0-9]{1}){2,20}$/;
                return phoneRegex.test(phoneNumber);
            };

            var itemSelectedEvent = $itemSelector.events.onItemSelected;

            var otherPrimaryConcernId = snap.dataSource.Admin.Concern.Primary.otherConcernId;
            var otherSecondaryConcernId = snap.dataSource.Admin.Concern.Secondary.otherConcernId;

            this.zonedStart = opt.zonedStart || null;
            this.zonedEnd = opt.zonedEnd || null;
            this.appointmentTypeCode = opt.appointmentTypeCode || $scheduleCommon.appointmentTypeCode.clinicianScheduled;
            this.isTimezoneReadOnly = true;

            this._blockPermission = $scheduleCommon.blockPermissions.allowProviderAppt;

            var that = this;

            function onPatientSelected() {
                var patient = that.patientsSelector.getSelectedItem();
                if (patient) {
                    that.cliniciansSelector.counterpartFilter = patient.personId;
                    that.cliniciansSelector.refresh();
                }
            }

            function onClinicianSelected() {
                var clinician = that.cliniciansSelector.getSelectedItem();
                if (clinician) {
                    that.patientsSelector.counterpartFilter = clinician.personId;
                    that.patientsSelector.refresh();
                }
            }
            this.cliniciansSelector = $itemSelector.cliniciansSelector({ defaultItem: defaultClinician });
            this.patientsSelector = displayOpt.userType === $scheduleCommon.userType.patient ? $itemSelector.emptySelector({ defaultItem: defaultPatient }) : $itemSelector.patientsSelector({ defaultItem: defaultPatient });
            this.patientsSelector.on(itemSelectedEvent, onPatientSelected);
            this.cliniciansSelector.on(itemSelectedEvent, onClinicianSelected);

            this.isReschedulable = opt.isReschedulable;

            this.timeZoneDs = timeZoneDataSource;

            this.serviceTypeId = null;
            this.serviceTypeName = opt.serviceTypeName || "";

            this.vm_isReschedulable = opt.isReschedulable;
            this.vm_canShowTimeOffsets = false;
            this.vm_isTimeOffsetsVisible = false;

            this._defaultIntervalSetting = "";

            this._dismissed = false;
            this.vm_dismissedReason = "";
            this.phoneNumber = "";
            this.phoneType = "";

            this.phoneTypeDs = new kendo.data.DataSource({
                data: [{
                    text: "Home",
                    value: phoneTypeEnum.home
                }, {
                    text: "Mobile",
                    value: phoneTypeEnum.mobile
                }, {
                    text: "Other",
                    value: phoneTypeEnum.other
                }]
            });

            this._setOptionsForConcreteEventType = function(opt) {
                this.availabilityBlockId = opt.availabilityBlockId ? opt.availabilityBlockId : null;
                this.waiveFee = opt.waiveFee;

                this.encounterTypeCode = opt.encounterTypeCode ? opt.encounterTypeCode : encounterTypeCodes.Video;

                this.primaryConcern = null;
                this.secondaryConcern = null;

                this.vm_primaryConsernId = null;
                this.vm_secondaryConsernId = null;
                this.displaySecondaryConcern = false;
                this.dataPrimaryConcernList = [];
                this.dataSecondaryConcernList = [];
                this.primaryConcernOtherText = "";
                this.secondaryConcernOtherText = "";
                this.additionalNotes = "";
                this.vm_isAddNotesExpanded = false;
                this.phoneNumber = opt.phoneNumber;
                this.phoneType = opt.phoneType || phoneTypeEnum.home;
                this.serviceTypeId = opt.serviceTypeId || null;
                this.serviceTypeName = opt.serviceTypeName || "";
                this._dismissed = opt.dismissed;

                if (opt.intakeMetadata) {
                    this.additionalNotes = opt.intakeMetadata.additionalNotes ? opt.intakeMetadata.additionalNotes : "";

                    if (opt.intakeMetadata.concerns && opt.intakeMetadata.concerns.length > 0) {
                        var concerns = opt.intakeMetadata.concerns;
                        for (var i = 0; i < concerns.length; i++) {
                            if (concerns[i].isPrimary) {
                                this.primaryConcern = concerns[i];
                                this.vm_primaryConsernId = concerns[i].customCode.code;
                                this.primaryConcernOtherText = concerns[i].customCode.description;
                            } else {
                                this.secondaryConcern = concerns[i];
                                this.displaySecondaryConcern = true;
                                this.vm_secondaryConsernId = concerns[i].customCode.code;
                                this.secondaryConcernOtherText = concerns[i].customCode.description;
                            }
                        }
                    }
                }
            };

            this._updateSelectorTime = function(useCahedValue) {
                this.patientsSelector.updateEventTime(this.start, this.end, this.timeZoneId, useCahedValue);
                this.cliniciansSelector.updateEventTime(this.start, this.end, this.timeZoneId, useCahedValue);
            };

            //****************** Call BASE constructor ********************
            SchedulerDialog.call(this, opt);

            //******************************** On dialog show **********************************/
            this._checkProvider = function(clinician, clinicianId) {
                var dfd = $.Deferred();
                var that = this;
                if (clinicianId) {
                    $availabilityBlockService.getClinicianProfile(snap.hospitalSession.hospitalId, clinicianId).then(function(responce) {
                        if (responce && responce.data && responce.data.length) {
                            var clinicianObj = $itemSelector.convertPersonToSelectorItem(responce.data[0].person, clinicianId, $itemSelector.personType.clinician, responce.data[0].specialty);
                            that.cliniciansSelector.selectItem(clinicianObj);
                            onClinicianSelected();
                            dfd.resolve(true);
                        } else {
                            that.set("isDisabled", true);
                            if (clinician) {
                                var clinicianObj = $itemSelector.convertPersonToSelectorItem(clinician.person, clinicianId, $itemSelector.personType.clinician, clinician.specialty);
                                that.cliniciansSelector.selectItem(clinicianObj);
                                that.cliniciansSelector.disableSelectedItem();
                            }
                            dfd.resolve(false);
                        }
                    }, function() {
                        that.set("isDisabled", true);
                        if (clinician) {
                            var clinicianObj = $itemSelector.convertPersonToSelectorItem(clinician.person, clinicianId, $itemSelector.personType.clinician, clinician.specialty);
                            that.cliniciansSelector.selectItem(clinicianObj);
                            that.cliniciansSelector.disableSelectedItem();
                        }
                        dfd.resolve(false);
                    });
                } else {
                    dfd.resolve(true);
                }
                return dfd.promise();
            };

            var getPatientProfileForPatient = function(patientId) {
                var dfd = $.Deferred();
                $availabilityBlockService.getPatientProfileForPatient(patientId).then(function(responce) {
                    if (responce && responce.data && responce.data.length) {
                        var data = responce.data[0];
                        var patientProfile = {
                            person: {
                                id: patientId,
                                photoUrl: data.profileImagePath,
                                name: {
                                    given: data.patientName,
                                    family: data.lastName
                                },
                                phones: [
                                    { use: "other", value: data.mobilePhone },
                                    { use: "home", value: data.homePhone }
                                ]
                            }
                        };
                        dfd.resolve({ data: [patientProfile] });
                    }
                }, function(error) {
                    dfd.reject(error);
                });
                return dfd.promise();
            };
            this._checkPatient = function(patient, patientId, userType) {
                var dfd = $.Deferred();
                var that = this;
                if (patientId) {
                    var getPatientProfilePromise = userType == $scheduleCommon.userType.patient ?
                        getPatientProfileForPatient(patientId) :
                        $availabilityBlockService.getPatientProfile(snap.hospitalSession.hospitalId, patientId);
                    getPatientProfilePromise.then(function(responce) {
                        if (responce && responce.data && responce.data.length) {
                            var patientObj = $itemSelector.convertPersonToSelectorItem(responce.data[0].person, patientId, $itemSelector.personType.patient);
                            that.patientsSelector.selectItem(patientObj);
                            onPatientSelected();
                            dfd.resolve(true);
                        } else {
                            that.set("isDisabled", true);
                            if (patient) {
                                var patientObj = $itemSelector.convertPersonToSelectorItem(patient.person, patientId, $itemSelector.personType.patient);
                                that.patientsSelector.selectItem(patientObj);
                                that.patientsSelector.disableSelectedItem();
                            }
                            dfd.resolve(false);
                        }
                    }, function() {
                        that.set("isDisabled", true);
                        if (patient) {
                            var patientObj = $itemSelector.convertPersonToSelectorItem(patient.person, patientId, $itemSelector.personType.patient);
                            that.patientsSelector.selectItem(patientObj);
                            that.patientsSelector.disableSelectedItem();
                        }
                        dfd.resolve(false);
                    });
                } else {
                    dfd.resolve(true);
                }
                return dfd.promise();
            };
            this._loadConcerns = function() {
                var dfd = $.Deferred();
                var that = this;
                var primaryPromise = $availabilityBlockService.getPrimaryConcerns();
                var secondaryPromise = $availabilityBlockService.getSecondaryConcerns();

                $.when(primaryPromise, secondaryPromise).then(function(primaryConcerns, secondaryConcerns) {
                    that.set("dataPrimaryConcernList", primaryConcerns);
                    that.set("dataSecondaryConcernList", secondaryConcerns);

                    if (that.primaryConcern) {
                        that.set("vm_primaryConsernId", that.primaryConcern.customCode.code);
                        that.trigger("change", { field: "vm_primaryConsernId" });
                    }

                    if (that.secondaryConcern) {
                        that.set("vm_secondaryConsernId", that.secondaryConcern.customCode.code);
                        that.trigger("change", { field: "vm_secondaryConsernId" });
                    }

                    if (snap.dataSource.Admin.Concern.Primary.OtherConcern) {
                        snap.dataSource.Admin.Concern.Primary.OtherConcern.fetch().done(function() {
                            var data = snap.dataSource.Admin.Concern.Primary.OtherConcern.data();
                            if (data.length > 0) {
                                otherPrimaryConcernId = data[0].id;
                                that.trigger("change", { field: "vm_isPrimaryConcernOtherSelected" });
                            }
                            if (snap.dataSource.Admin.Concern.Secondary.OtherConcern) {
                                snap.dataSource.Admin.Concern.Secondary.OtherConcern.fetch().done(function() {
                                    var data = snap.dataSource.Admin.Concern.Secondary.OtherConcern.data();
                                    if (data.length > 0) {
                                        otherSecondaryConcernId = data[0].id;
                                        that.trigger("change", { field: "vm_isSecondaryConcernOtherSelected" });
                                    }
                                    dfd.resolve();
                                });
                            } else {
                                dfd.resolve();
                            }
                        });
                    } else {
                        dfd.resolve();
                    }
                }, function() {
                    dfd.reject();
                });
                return dfd.promise();
            };

            this._loadDetails = function(userType) {
                var dfd = $.Deferred();
                scope = this;

                if (this._initEvents) {
                    this._initEvents();
                }

                if (this._deepLoadDetails) {
                    this._deepLoadDetails();
                }

                var clinician = $scheduleCommon.findProvider(opt.participants);
                var patient = $scheduleCommon.findPatient(opt.participants);

                this._updateSelectorTime();
                this.refreshEncounterType();
                this.set("vm_isPhoneNumberFilled", validatePhoneNumber(this.phoneNumber));
                this.set("vm_serviceTypeActive", this.serviceTypeId !== null);

                this.set("vm_primaryConcernActive", this.vm_primaryConsernId !== null);
                this.set("vm_secondaryConcernActive", this.vm_secondaryConsernId !== null);
                this.set("vm_isAddNotesExpanded", !!this.additionalNotes.length);

                this.set("isReadOnly", this.isReadOnly || !this.vm_isNew() && ($scheduleCommon.isAppointmentReadOnly(opt.appointmentStatusCode) || isReadOnly(userType, clinician, opt.clinicianId)));
                this.trigger("change", { field: "vm_isNotReadOnly" });

                var selectedService = {
                    serviceTypeId: this.serviceTypeId,
                    description: this.serviceTypeName
                };
                this.set("serviceTypesSource", getServiceTypesDataSource(this.isReadOnly, selectedService));
                this.serviceTypesSource.read().done(function() {
                    scope.trigger("change", { field: "serviceTypeId" });
                    $eventAggregator.published(events.serviceTypesLoaded);
                });

                this.timeZoneDs.read().done(function() {
                    scope.selectedTimeZone = scope.timeZoneDs.data().find(function(el) {
                        return el.id === scope.timeZoneId;
                    });
                    scope.set("vm_timeZoneActive", scope.selectedTimeZone !== null);
                    scope.trigger("change", { field: "selectedTimeZone" });
                });

                this.set("isRepeaterVisible", isRepeaterVisible(userType, this.isRepeat, this.vm_isNew(), this.appointmentTypeCode));

                if (this.start) {
                    this.set("vm_isSelectedStartDate", true);
                }

                if (this.end) {
                    this.set("vm_isSelectedEndDate", true);
                }
                this.trigger("change", { field: "vm_isCancelBtnVisible" });
                this.trigger("change", { field: "vm_saveBtnTxt" });

                this.cliniciansSelector.set("isSelectorLocked", this.isReadOnly || isCliniciansSelectorLocked(userType));
                this.patientsSelector.refresh();
                this.patientsSelector.set("isSelectorLocked", this.isReadOnly || isPatientSelectorLocked(userType, clinician, opt.clinicianId));

                this.trigger("change", { field: "vm_isAddConcernButtonVisible" });
                this.trigger("change", { field: "vm_apptHeaderText" });
                this.trigger("change", { field: "vm_isCancelButtonVisible" });
                this.trigger("change", { field: "vm_showDismissReason" });

                if (!this.vm_isNew()) {
                    this.patientsSelector.selectWithConfirmation = true;
                    this.patientsSelector.on($itemSelector.events.onItemClicked, function(item) {
                        $snapNotification.confirmationWithCallbacks("Are you sure you want to change the patient for this appointment? (This will send a cancellation notice to the previous patient.)", function() {
                            scope.patientsSelector.selectHandler(item);
                        });
                    });
                }

                scope.patientsSelector.on($itemSelector.events.onSelectorHide, scope.setInitialFocus);
                scope.cliniciansSelector.on($itemSelector.events.onSelectorHide, scope.setInitialFocus);

                $availabilityBlockService.getUserCurrentTime().done(function(resp) {
                    var userDNATime = $timeUtils.dateFromSnapDateString(resp.data[0]);
                    userDNATime.setMinutes(userDNATime.getMinutes() - 30);
                    scope.set("isFuture", userType === $scheduleCommon.userType.patient && !scope.isReadOnly && (userDNATime <= scope.end));
                    scope.trigger("change", { field: "vm_isCancelButtonVisible" });

                    $.when(scope._checkProvider(clinician, opt.clinicianId), scope._checkPatient(patient, opt.patientId, userType)).then(function() {
                        scope.set("vm_canShowTimeOffsets",
                            scope.patientsSelector.getSelectedItem() !== null && scope.cliniciansSelector.getSelectedItem() !== null);
                        if (!scope.isReadOnly) {
                            scope._validateOnChange = true;

                            scope.patientsSelector.on(itemSelectedEvent, function() {
                                onItemSelectedEvent($itemSelector.personType.patient);
                            });
                            scope.cliniciansSelector.on(itemSelectedEvent, function() {
                                onItemSelectedEvent($itemSelector.personType.clinician);
                            });

                            function onItemSelectedEvent(personType) {
                                scope.set("phoneNumber", "");
                                scope.vm_onPhoneTypeChange();

                                var isClinicianSelected = personType === $itemSelector.personType.clinician;
                                var activeSelector = isClinicianSelected ? scope.cliniciansSelector : scope.patientsSelector;
                                var otherSelector = isClinicianSelected ? scope.patientsSelector : scope.cliniciansSelector;

                                scope._onDataChange();
                                activeSelector.showTimeOffset(scope.vm_isTimeOffsetsVisible);
                                scope.vm_disableSelectError(personType);

                                if (scope.isDisabled && scope._validateOnChange) {
                                    var otherSelectorSelectedItem = otherSelector.getSelectedItem();
                                    var otherSelectorOk = !otherSelectorSelectedItem || !otherSelectorSelectedItem.isDisabled;

                                    var selectedItem = activeSelector.getSelectedItem();
                                    var checkPromise = isClinicianSelected ? scope._checkProvider(selectedItem, selectedItem.id) :
                                        scope._checkPatient(selectedItem, selectedItem.id);
                                    checkPromise.done(function(ok) {
                                        activeSelector.showTimeOffset(scope.vm_isTimeOffsetsVisible);
                                        if (ok && otherSelectorOk) {
                                            scope.set("isDisabled", false);
                                            scope._validateOnChange = false;
                                        }
                                    });
                                }
                            }
                            scope._loadConcerns().done(function() {
                                dfd.resolve();
                            });
                        } else {
                            dfd.resolve();
                        }
                    }, function() {
                        dfd.reject();
                    });
                });

                return dfd.promise();
            };

            function isCliniciansSelectorLocked(userType) {
                if (userType === $scheduleCommon.userType.admin) {
                    return false;
                }

                return true;
            }

            function isPatientSelectorLocked(userType, clinician, clinicianId) {
                if (userType === $scheduleCommon.userType.admin) {
                    return false;
                } else if (userType === $scheduleCommon.userType.clinician) {
                    if (!clinician) {
                        return false;
                    } else {
                        return clinicianId !== snap.profileSession.userId;
                    }
                }
                return true;
            }

            function isReadOnly(userType, clinicican, clinicicanId) {
                if (userType === $scheduleCommon.userType.clinician) {
                    return (!(typeof(clinicican) === "undefined" || clinicican === null || clinicicanId === snap.profileSession.userId));
                } else {
                    return userType === $scheduleCommon.userType.patient;
                }
            }


            //******************************* MVVM BINDINGS ************************************/
            this._onDataChange = function() {
                if (!this.vm_appointmentChanged) {
                    this.set("vm_appointmentChanged", true);
                    this.trigger("change", { field: "vm_isCancelBtnVisible" });
                }
            };

            this.isVideo = function() {
                return this.encounterTypeCode == encounterTypeCodes.Video;
            };
            this.isPhone = function() {
                return this.encounterTypeCode == encounterTypeCodes.Phone;
            };
            this.isText = function() {
                return this.encounterTypeCode == encounterTypeCodes.Text;
            };
            this.isInPerson = function() {
                return this.encounterTypeCode == encounterTypeCodes.InPerson;
            };
            this.refreshEncounterType = function() {
                this.trigger("change", { field: "isVideo" });
                this.trigger("change", { field: "isPhone" });
                this.trigger("change", { field: "isText" });
                this.trigger("change", { field: "isInPerson" });
            };
            var setEncounterType = function (encounterTypeCode) {
                    scope.set("encounterTypeCode", encounterTypeCode);
                    scope.refreshEncounterType();
                    scope._onDataChange();
            };
            this.setVideoType = function () {
                setEncounterType(encounterTypeCodes.Video);
            };
            this.setPhoneType = function () {
                setEncounterType(encounterTypeCodes.Phone);
            };
            this.isPhoneConsultationDisabled = function () {
                return snap && snap.hospitalSettings.disablePhoneConsultation;
            }
            this.setTextType = function() {
                setEncounterType(encounterTypeCodes.Text);
            };
            this.setInPersonType = function() {
                setEncounterType(encounterTypeCodes.InPerson);
            };
            var setEncounterType = function(encounterTypeCode) {
                scope.set("encounterTypeCode", encounterTypeCode);
                scope.refreshEncounterType();
                scope._onDataChange();
            };

            this.patientNumber = "";
            this.vm_isSelectedStartDate = false;
            this.vm_isSelectedEndDate = false;
            this.vm_appointmentChanged = false;
            this.vm_primaryConcernActive = false;
            this.vm_primaryConcernError = false;
            this.vm_secondaryConcernActive = false;
            this.vm_secondaryConcernError = false;

            this.vm_isNotReadOnly = function() {
                return !this.isReadOnly;
            };

            this.vm_showDismissReason = function() {
                return this.userType !== $scheduleCommon.userType.patient && this._dismissed;
            };

            this.vm_isAddConcernButtonVisible = function() {
                return !this.isReadOnly && !this.displaySecondaryConcern && this.vm_primaryConsernId !== null;
            };

            this.vm_isCancelBtnVisible = function() {
                return !this.vm_appointmentChanged && !this.vm_isNew();
            };

            this.vm_userTrayHeaderText = function() {
                return "Who is this appointment for?";
            };

            this.vm_apptHeaderText = function() {
                if (this.vm_isNew()) {
                    return "New Appointment";
                }

                return this.isReadOnly ? "Appointment" : "Edit Appointment";
            };

            this.vm_saveBtnTxt = function() {
                return this.vm_isNew() ? "Create" : "Save";
            };

            function isRepeaterVisible(userType, isRepeat, isNew, appointmentTypeCode) {
                if (appointmentTypeCode === $scheduleCommon.appointmentTypeCode.patientScheduled) {
                    return false;
                }
                if (isNew) {
                    return true;
                }

                if (userType == $scheduleCommon.userType.patient) {
                    return isRepeat ? true : false;
                } else {
                    return true;
                }

            }

            this.vm_isPrimaryConcernOtherSelected = function() {
                return this.vm_primaryConsernId === otherPrimaryConcernId;
            };

            this.vm_isSecondaryConcernOtherSelected = function() {
                return this.vm_secondaryConsernId === otherSecondaryConcernId;
            };

            this.vm_expandAddNotes = function() {
                this.set("vm_isAddNotesExpanded", !this.vm_isAddNotesExpanded);
            };

            this.vm_showTimeOffsets = function() {
                var flag = !this.vm_isTimeOffsetsVisible;
                this.set("vm_isTimeOffsetsVisible", flag);
                this.patientsSelector.showTimeOffset(flag);
                this.cliniciansSelector.showTimeOffset(flag);
            };

            this.vm_onAddConcernClick = function(e) {
                this.preventDefault(e);
                this.set("displaySecondaryConcern", true);
                this.trigger("change", { field: "vm_isAddConcernButtonVisible" });
                this._onDataChange();
            };

            this.vm_onRemoveSecondaryConcernClick = function() {
                this.set("vm_secondaryConcernError", false);
                this.set("vm_secondaryConcernActive", false);
                if (this._concernsSimilarError) {
                    this.set("vm_primaryConcernError", false);
                    this.set("vm_primaryConcernActive", this.vm_primaryConsernId !== null);
                    this._concernsSimilarError = false;
                }
                this.set("displaySecondaryConcern", false);
                this.set("vm_secondaryConsernId", null);
                this.secondaryConcern = null;
                this.set("secondaryConcernOtherText", "");
                this.trigger("change", { field: "vm_isSecondaryConcernOtherSelected" });
                this.trigger("change", { field: "vm_isAddConcernButtonVisible" });
                this._onDataChange();
            };

            this.vm_onPrimaryConcernChange = function() {
                this.trigger("change", { field: "vm_isPrimaryConcernOtherSelected" });
                this.trigger("change", { field: "vm_isAddConcernButtonVisible" });

                this.set("vm_primaryConcernError", false);
                if (this._concernsSimilarError) {
                    this.set("vm_secondaryConcernError", false);
                    this.set("vm_secondaryConcernActive", this.vm_secondaryConsernId !== null);
                    this._concernsSimilarError = false;
                }
                this.set("vm_primaryConcernActive", this.vm_primaryConsernId !== null);

                var concern = this._formatConcernData(this.dataPrimaryConcernList, this.vm_primaryConsernId, true);

                if (!this.vm_isPrimaryConcernOtherSelected() && this.primaryConcernOtherText !== "") {
                    this.set("primaryConcernOtherText", "");
                }

                if (this.vm_isPrimaryConcernOtherSelected()) {
                    $('span.dialogbox-master__reason-dropdown').first().addClass('is-active');
                    concern.customCode.description = this.get("primaryConcernOtherText");
                } else {
                    $('span.dialogbox-master__reason-dropdown').first().removeClass('is-active');
                }

                this.primaryConcern = concern;

                this._onDataChange();
            };

            this.vm_onSecondaryConcernChange = function() {
                this.trigger("change", { field: "vm_isSecondaryConcernOtherSelected" });

                var concern = this._formatConcernData(this.dataSecondaryConcernList, this.vm_secondaryConsernId, false);

                this.set("vm_secondaryConcernError", false);
                if (this._concernsSimilarError) {
                    this.set("vm_primaryConcernError", false);
                    this.set("vm_primaryConcernActive", this.vm_primaryConsernId !== null);
                    this._concernsSimilarError = false;
                }
                this.set("vm_secondaryConcernActive", this.vm_secondaryConsernId !== null);

                if (!this.vm_isSecondaryConcernOtherSelected() && this.secondaryConcernOtherText !== "") {
                    this.set("secondaryConcernOtherText", "");
                }

                if (this.vm_isSecondaryConcernOtherSelected()) {
                    $('span.dialogbox-master__reason-dropdown').last().addClass('is-active');
                    concern.customCode.description = this.get("secondaryConcernOtherText");
                } else {
                    $('span.dialogbox-master__reason-dropdown').last().removeClass('is-active');
                }

                this.secondaryConcern = concern;

                this._onDataChange();
            };

            this.vm_onPhoneNumberChange = function() {
                this.set("vm_phoneNumberError", false);
                this.set("vm_isPhoneNumberFilled", $.trim(this.phoneNumber) !== "");
                if (this.phoneType !== phoneTypeEnum.other) {
                    this.set("phoneType", phoneTypeEnum.other);
                }
                this._onDataChange();
            };

            this.vm_onPhoneTypeChange = function() {
                // get phone type
                // get phone from person from selector
                // update phone field
                // TODO: remove filter Function to utilities or replace with ES6 or underscore / lodash libraries
                try {
                    var _phoneType = this.phoneType;

                    var filterFunc = function(array, callback) {
                        var result = [];
                        for (var i = 0; i < array.length; i++) {
                            if (callback(array[i])) {
                                result.push(array[i]);
                            }
                        }
                        return result;
                    };

                    var callback = function(a) {
                        return phoneTypeEnum[a] == _phoneType;
                    };

                    var typeName = filterFunc(Object.keys(phoneTypeEnum), callback)[0];

                    //if there is a selected patient
                    if (this.patientsSelector.getSelectedItem()) {
                        var phones = this.patientsSelector.getSelectedItem().data.person.phones;
                        var callback2 = function(b) {
                            return b.use == typeName;
                        };
                        var numberVal = filterFunc(phones, callback2);

                        if (numberVal.length > 0) {
                            this.set("phoneNumber", numberVal[0].value);
                        } else {
                            this.set("phoneNumber", "");
                        }
                    }
                } catch (exp) {
                    window.console.error(exp);
                }

                this._onDataChange();
            };

            this.vm_onKeyUpAdditionalNotes = function() {
                this._onDataChange();
            };

            //*********************** PRIVATE METHODS ***********************/

            this._formatConcernData = function(concernList, selectedConcernId, isPrimary) {
                var concerns = concernList.data().filter(function(concern) {
                    return concern.codeId === selectedConcernId;
                });

                if (concerns.length > 0) {
                    return {
                        isPrimary: isPrimary,
                        customCode: {
                            code: selectedConcernId,
                            description: concerns[0].text
                        }
                    };
                }

                return null;
            };

            this._validateDetails = function() {
                var errorList = [];

                if (this.cliniciansSelector.getSelectedItem() === null) {
                    errorList.push("Select a Provider.");
                    this.set("vm_isProviderSelectError", true);
                    this.set("vm_canShowTimeOffsets", false);
                }

                if (this.patientsSelector.getSelectedItem() === null) {
                    errorList.push("Select a Patient.");
                    this.set("vm_isPatientSelectError", true);
                    this.set("vm_canShowTimeOffsets", false);
                }

                if ((this.vm_primaryConsernId !== null) && (this.displaySecondaryConcern && this.vm_secondaryConsernId !== null) && this.vm_secondaryConsernId !== otherSecondaryConcernId && this.primaryConcern.customCode.description === this.secondaryConcern.customCode.description) {
                    errorList.push("Primary and Secondary Concerns must be different.");
                    this.set("vm_primaryConcernError", true);
                    this.set("vm_secondaryConcernError", true);
                    this._concernsSimilarError = true;
                    this.set("vm_primaryConcernActive", false);
                    this.set("vm_secondaryConcernActive", false);
                }

                if ((this.vm_secondaryConsernId === otherSecondaryConcernId && this.vm_primaryConsernId === otherPrimaryConcernId) && ($.trim(this.primaryConcernOtherText) === $.trim(this.secondaryConcernOtherText))) {
                    errorList.push("Primary and Secondary Concerns must be different.");
                    this.set("vm_primaryConcernError", true);
                    this.set("vm_secondaryConcernError", true);
                    this._concernsSimilarError = true;
                    this.set("vm_primaryConcernActive", false);
                    this.set("vm_secondaryConcernActive", false);
                }

                if (this.vm_primaryConsernId === null) {
                    errorList.push("Select or enter a Primary Concern.");
                    this.set("vm_primaryConcernError", true);
                    this.set("vm_primaryConcernActive", false);
                    this._concernsSimilarError = false;
                }

                if (this.vm_primaryConsernId === otherPrimaryConcernId && $.trim(this.primaryConcernOtherText) === "") {
                    errorList.push("Enter Primary Concern.");
                    this.set("vm_primaryConcernError", true);
                    this.set("vm_primaryConcernActive", false);
                    this._concernsSimilarError = false;
                }

                if (this.displaySecondaryConcern && this.vm_secondaryConsernId === null) {
                    errorList.push("Select Secondary Concern.");
                    this.set("vm_secondaryConcernError", true);
                    this.set("vm_secondaryConcernActive", false);
                    this._concernsSimilarError = false;
                }

                if (this.vm_secondaryConsernId === otherSecondaryConcernId && $.trim(this.secondaryConcernOtherText) === "") {
                    errorList.push("Enter Secondary Concern.");
                    this.set("vm_secondaryConcernError", true);
                    this.set("vm_secondaryConcernActive", false);
                    this._concernsSimilarError = false;
                }

                if (this.encounterTypeCode === encounterTypeCodes.Phone) {
                    var phoneNumber = $.trim(this.phoneNumber);
                    phoneNumber = phoneNumber.replace(/\s\s+/, " ");
                    this.set("phoneNumber", phoneNumber);
                    if (this.phoneNumber === "") {
                        errorList.push("Enter a Phone number.");
                        this.set("vm_phoneNumberError", true);
                        this.set("vm_isPhoneNumberFilled", false);
                    } else if (!validatePhoneNumber(this.phoneNumber)) {
                        errorList.push("Wrong phone number format.");
                        this.set("vm_phoneNumberError", true);
                        this.set("vm_isPhoneNumberFilled", false);
                    }
                }
                if (this.serviceTypeId === null) {
                    errorList.push("Select a Service Type");
                    this.set("vm_serviceTypeError", true);
                    this.set("vm_serviceTypeActive", false);
                }

                if (this.selectedTimeZone === null) {
                    errorList.push("Select a Timezone");
                    this.set("vm_timeZoneError", true);
                    this.set("vm_timeZoneActive", false);
                }
                if (this._deepValidateDetails) {
                    errorList = errorList.concat(this._deepValidateDetails());
                }

                return errorList;
            };
        }

        function Appointment(opt, displayOpt) {
            var scope = this;

            this._type = $scheduleCommon.eventType.appointment;
            this._typeName = "Appointment";
            this._defaultInterval = 15;

            this.appointmentStatusCode = opt.appointmentStatusCode;
            this.isReadOnly = displayOpt.forceReadOnly;

            this._onSubmitClickEvent = "appt_onSubmitClick";
            this._onCloseClickEvent = "appt_onCloseClick";
            this._onRemoveClickEvent = "appt_onRemoveClick";
            this._onRescheduleEvent = "appt_onReschedule";
            this._removeCurrentEventMessage = "Are you sure that you want to cancel this Appointment?";
            this._removedSuccesfullyMessage = "The Appointment was removed successfully";

            //****************** Call BASE constructor ********************
            ConsultationDialog.call(this, opt, displayOpt);

            this._getOptionsForConcreteEventType = function() {
                var concerns = [];
                if (this.primaryConcern) {
                    concerns.push(this.primaryConcern);
                }

                if (this.secondaryConcern) {
                    concerns.push(this.secondaryConcern);
                }

                var participants = [];
                var clinicianId = null;
                var patientId = null;

                var clinician = this.cliniciansSelector.getSelectedItem();
                if (clinician) {
                    participants.push({
                        appointmentId: this.id,
                        attendenceCode: $scheduleCommon.attendenceCode.required,
                        personId: clinician.data.person.id,
                        person: clinician.data.person,
                        participantTypeCode: $scheduleCommon.participantTypeCode.practicioner
                    });
                    clinicianId = clinician.id;
                }

                var patient = this.patientsSelector.getSelectedItem();
                if (patient) {
                    participants.push({
                        appointmentId: this.id,
                        attendenceCode: $scheduleCommon.attendenceCode.required,
                        personId: patient.data.person.id,
                        person: patient.data.person,
                        participantTypeCode: $scheduleCommon.participantTypeCode.patient
                    });
                    patientId = patient.id;
                }

                return {
                    appointmentTypeCode: this.appointmentTypeCode,
                    intakeMetadata: {
                        additionalNotes: this.additionalNotes,
                        concerns: concerns,
                    },
                    encounterTypeCode: this.encounterTypeCode,
                    participants: participants,
                    waiveFee: this.waiveFee,
                    clinicianId: clinicianId,
                    patientId: patientId,
                    phoneNumber: this.phoneNumber,
                    phoneType: this.phoneType,
                    serviceTypeId: this.serviceTypeId,
                    timeZoneId: this.timeZoneId,
                    startInCurrentUserTimezone: this.startInCurrentUserTimezone,
                    endInCurrentUserTimezone: this.endInCurrentUserTimezone,
                    zonedStart: this.zonedStart,
                    zonedEnd: this.zonedEnd
                };
            };

            this._initEvents = function() {
                scope = this;
                $eventAggregator.subscriber(events.serviceTypeChanged, function() {
                    var selectedServiceType = scope.serviceTypesSource.data().find(function(serviceType) {
                        return serviceType.serviceTypeId === scope.serviceTypeId;
                    });
                    if (selectedServiceType) {
                        var selectedServiceDuration = selectedServiceType.appointmentLengthMinutes;
                        var startCopy = new Date(scope.start);
                        scope.set("end", new Date(startCopy.setMinutes(startCopy.getMinutes() + selectedServiceDuration)));
                        scope.set("appointmentTypeCode", selectedServiceType.appointmentType);
                        scope.vm_onEndDateChange();
                    }
                });
            };

            this._validateTimeDetails = function(currentUserTime) {
                var errorList = [];
                var startTime = this.startInCurrentUserTimezone || this.start;
                // set a 0.5 hour block in the past padding
                currentUserTime.setMinutes(currentUserTime.getMinutes() - 30);
                if (currentUserTime > startTime) {
                    errorList.push("Block start time should not be in the past.");
                    this.set("vm_startDateError", true);
                    this.set("vm_isSelectedStartDate", false);

                    this.set("vm_endDateError", true);
                    this.set("vm_isSelectedEndDate", false);
                }
                return errorList;
            };


            this.vm_isCancelButtonVisible = function() {
                return !this.vm_isNew() && (!this.isReadOnly || this.isFuture);
            };

            this.saveAll = function() {
                var rule = null;
                if (this._isAffectSeries()) {
                    rule = this.repeater.getRepeatRule(this.startInCurrentUserTimezone, this.endInCurrentUserTimezone, 1);
                }

                return $eventService.saveAppointment(this.getOptions(), rule);
            };

            //******************************* PUBLIC API **************************************/
            this.removeAll = function() {
                return this.userType === $scheduleCommon.userType.patient ? snap.patient.schedule.patientAppointmentService().removeAppointment(this.getOptions().id) : $eventService.cancelAppointment(this.getOptions());
            };
        }

        function DocumentEncounter(opt, displayOpt) {
            var scope = this;

            var serviceDurations = [];

            this._type = $scheduleCommon.eventType.documentEncounter;
            this._typeName = "Document Encounter";
            this._defaultInterval = 5;
            this.durationPeriod = null;
            this.isRuleAvailable = false;
            this.isReadOnly = false;

            this.subjective = "";
            this.objective = "";
            this.assessment = "";
            this.plan = "";

            this.vm_isNext = false;
            this.vm_isSubjectiveExpanded = false;
            this.vm_isObjectiveExpanded = false;
            this.vm_isAssessmentExpanded = false;
            this.vm_isPlanExpanded = false;

            this._onSubmitClickEvent = "encDoc_onSubmitClick";
            this._onCloseClickEvent = "encDoc_onCloseClick";

            //****************** Call BASE constructor ********************
            ConsultationDialog.call(this, opt, displayOpt);
            this.isRepeat = false;

            this.durationPeriodTypes = function() {
                var periods = [];
                serviceDurations.forEach(function(el) {
                    periods.push({
                        value: el,
                        text: el
                    });
                });
                return new kendo.data.DataSource({
                    data: periods
                });
            };

            var modifyEncounterConcern = function(concern) {
                return {
                    isPrimary: concern.isPrimary,
                    description: concern.customCode.description
                };
            };

            this._isAffectSeries = function() {
                return false;
            };

            this._initEvents = function() {
                scope = this;
                $eventAggregator.subscriber(events.serviceTypesLoaded, function() {
                    serviceDurations = [];
                    scope.serviceTypesSource.data().forEach(function(item) {
                        serviceDurations.push(item.appointmentLengthMinutes);
                    });
                    serviceDurations.sort(function(item1, item2) {
                        return item1 < item2 ? -1 : 1;
                    });
                    serviceDurations = serviceDurations.filter(function(item, index) {
                        return serviceDurations.indexOf(item) === index;
                    });
                    scope.trigger("change", { field: "durationPeriodTypes" });
                });
                $eventAggregator.subscriber(events.serviceTypeChanged, function() {
                    var selectedServiceType = scope.serviceTypesSource.data().find(function(serviceType) {
                        return serviceType.serviceTypeId === scope.serviceTypeId;
                    });
                    if (selectedServiceType) {
                        scope.set("durationPeriod", selectedServiceType.appointmentLengthMinutes);
                        scope.vm_onChangeDuration();
                    }
                });
            };

            var codesToArray = function(codes) {
                var result = [];
                codes.forEach(function(code) {
                    result.push(code.id);
                });
                return result;
            };

            this._getOptionsForConcreteEventType = function() {
                var concerns = [];
                if (this.primaryConcern) {
                    concerns.push(modifyEncounterConcern(this.primaryConcern));
                }

                if (this.secondaryConcern) {
                    concerns.push(modifyEncounterConcern(this.secondaryConcern));
                }

                var patient = this.patientsSelector.getSelectedItem();
                var patientId = patient ? patient.id : null;

                return {
                    end: this.end,
                    patientId: patientId,
                    soapNote: {
                        subjective: this.subjective,
                        objective: this.objective,
                        assessment: this.assessment,
                        plan: this.plan
                    },
                    phoneNumber: this.phoneNumber,
                    phoneType: this.phoneType,
                    serviceTypeId: this.serviceTypeId,
                    additionalNotes: this.additionalNotes,
                    encounterTypeCode: this.encounterTypeCode,
                    concerns: concerns,
                    medicalCodesIds: codesToArray(this.cptCodesSelector.getSelectedItems()).concat(codesToArray(this.icdCodesSelector.getSelectedItems())),
                    timeZoneId: this.timeZoneId,
                    startInCurrentUserTimezone: this.startInCurrentUserTimezone,
                    endInCurrentUserTimezone: this.endInCurrentUserTimezone,
                    zonedStart: this.zonedStart,
                    zonedEnd: this.zonedEnd
                };
            };

            this._calculateEndTime = function() {
                var duration = this.durationPeriod || this._defaultInterval;
                var startCopy = new Date(this.start);
                this.end = new Date(startCopy.setMinutes(startCopy.getMinutes() + duration));
            };

            this._validateTimeDetails = function(currentUserTime) {
                var errorList = [];
                var startTime = this.startInCurrentUserTimezone || this.start;
                // set a 0.5 hour block in the past padding
                if (currentUserTime < startTime) {
                    errorList.push("Consultation start time should not be in the future.");
                    this.set("vm_startDateError", true);
                    this.set("vm_isSelectedStartDate", false);
                }
                return errorList;
            };

            this._deepValidateDetails = function() {
                var errorList = [];
                if (!(/^[0-9]*$/.test(this.durationPeriod) && this.durationPeriod > 0 && this.durationPeriod < 1441)) {
                    errorList.push("Please enter an appointment time between 1 and 1440 minutes (24hrs).");
                    this.set("vm_durationPeriodError", true);
                    this.set("vm_durationPeriodActive", false);
                }
                return errorList;
            };

            this.saveAll = function() {
                return $eventService.saveEncounterDocument(this.getOptions());
            };

            this.vm_backClick = function() {
                this.set("vm_isNext", false);
            };

            this.vm_expandSubjective = function() {
                this.set("vm_isSubjectiveExpanded", !this.vm_isSubjectiveExpanded);
            };

            this.vm_expandObjective = function() {
                this.set("vm_isObjectiveExpanded", !this.vm_isObjectiveExpanded);
            };

            this.vm_expandAssessment = function() {
                this.set("vm_isAssessmentExpanded", !this.vm_isAssessmentExpanded);
            };

            this.vm_expandPlan = function() {
                this.set("vm_isPlanExpanded", !this.vm_isPlanExpanded);
            };

            this.vm_onChangeDuration = function() {
                // test for non digits and set error flag
                if (/^[0-9]*$/.test(this.durationPeriod) && this.durationPeriod > 0 && this.durationPeriod < 1441) {
                    this.set("vm_durationPeriodError", false);
                    this.set("vm_durationPeriodActive", this.durationPeriod !== null);
                    this._calculateEndTime();
                    this._updateSelectorTime(true);
                } else {
                    this.set("vm_durationPeriodError", true);
                }
            };

            this.vm_onNextClick = function(e) {
                var that = this;

                if (this.isLoading) {
                    this.preventDefault(e);
                    return false;
                }
                this._convertInputTimeToCurrentUserTimezone().done(function() {
                    var errors = that.validate();
                    that.validateTime().done(function(timeErrors) {
                        errors = errors.concat(timeErrors);
                        if (errors.length === 0) {
                            that.set("isError", false);
                            $snapNotification.hideAllConfirmations();
                            that.set("vm_isNext", true);
                        } else {
                            $snapNotification.error(errors.join("<br\>"));
                            that.set("isError", true);
                        }
                    });
                });
            };


            this._deepLoadDetails = function() {
                scope = this;

                // need init it in this way because kendo noDataTemplate does not work
                var cptCodesInput = $("input", "#cptCodesSelector");
                var cptAutoComplete = cptCodesInput.data("kendoAutoComplete");
                if (cptAutoComplete) {
                    scope.cptCodesSelector.initNoDataMessage(cptAutoComplete);
                }

                var icdCodesInput = $("input", "#icdCodesSelector");
                var icdAutoComplete = icdCodesInput.data("kendoAutoComplete");
                if (icdAutoComplete) {
                    scope.icdCodesSelector.initNoDataMessage(icdAutoComplete);
                }
            };

            this._initCodes = function() {
                var diagnosticCodingSystem = snap.hospitalSettings.mDiagnosticCodingSystem;
                var defaultMedicalSystemName = "Medical";

                var codingSystems = {
                    icd10: "ICD-10-DX",
                    icd9: "ICD-9-DX",
                    snomed: "SNOMED-CT"
                };
                var codingSystemShortNames = {
                    icd10: "ICD-10",
                    icd9: "ICD-9",
                    snomed: "SNOMED"
                };
                var wrapCodingSystemName = function(codingSystem) {
                    if (codingSystem == codingSystems.icd10) {
                        return codingSystemShortNames.icd10;
                    } else if (codingSystem == codingSystems.icd9) {
                        return codingSystemShortNames.icd9;
                    } else if (codingSystem == codingSystems.snomed) {
                        return codingSystemShortNames.snomed;
                    } else {
                        return codingSystem;
                    }
                };
                this.vm_isCptOn = snap.hospitalSettings.cPTCodes;
                this.vm_isDiagnosticOn = $.trim(diagnosticCodingSystem).length;

                if (this.vm_isCptOn && this.vm_isDiagnosticOn) {
                    this.vm_cptCodingSystemName = "Cpt";
                    this.vm_diagnosticCodingSystemName = wrapCodingSystemName(diagnosticCodingSystem);
                } else {
                    this.vm_cptCodingSystemName = defaultMedicalSystemName;
                    this.vm_diagnosticCodingSystemName = defaultMedicalSystemName;
                }

                var medicalCodesUrl = snap.baseUrl + "/api/v2/physicians/medicalcodes";

                var dataReadCptFilter = function(filter) {
                    return {
                        descriptionFilter: filter.filters[0].value,
                        medicalSystem: "CPT"
                    };
                };
                var dataReadIcdFilter = function(filter) {
                    return {
                        descriptionFilter: filter.filters[0].value,
                        medicalSystem: diagnosticCodingSystem
                    };
                };

                function MedicalCode(item, unselectHandler) {
                    this.id = item.id;
                    this.text = item.text;
                    this.data = item;
                    this.vm_onUnselectClick = function() {
                        unselectHandler(this);
                    };
                }

                this.cptCodesSelector = $multiselectControl.createNew({
                    constructor: MedicalCode
                });
                this.icdCodesSelector = $multiselectControl.createNew({
                    constructor: MedicalCode
                });

                if (this.vm_isCptOn) {
                    this.cptCodesSelector.createFilteringDataSource(medicalCodesUrl, "id", dataReadCptFilter);
                }
                if (this.vm_isDiagnosticOn) {
                    this.icdCodesSelector.createFilteringDataSource(medicalCodesUrl, "id", dataReadIcdFilter);
                }
            };

            this._initCodes();
        }

        this.createAvailabilityBlock = function(opt, displayOpt) {
            var object = $.extend(true, {}, emptyAvailabilityBlock, opt);

            displayOpt = $.extend(true, {}, defaultDisplayOptions, displayOpt);

            return new AvailabilityBlock(object, displayOpt);
        };

        this.isAvailabilityBlock = function(obj) {
            return obj instanceof AvailabilityBlock;
        };

        this.createAppointment = function(opt, displayOpt) {
            var object = $.extend(true, {}, emptyAppointment, opt);
            displayOpt = $.extend(true, {}, defaultDisplayOptions, displayOpt);

            return new Appointment(object, displayOpt);
        };

        this.createDocumentEncounter = function(opt, displayOpt) {
            var object = $.extend(true, {}, emptyEncounterDocument, opt);
            displayOpt = $.extend(true, {}, defaultDisplayOptions, displayOpt);

            return new DocumentEncounter(object, displayOpt);
        };

        this.isAppointment = function(obj) {
            return obj instanceof Appointment;
        };
    }).singleton();

}(jQuery, snap, kendo));

(function($, snap) {
    "use strict";

    snap.namespace("snap.admin.schedule").use(["snapNotification", "snap.admin.schedule.TimeUtils"])
        .define("apptRuleProcessor", function($snapNotification, $timeUtils) {
            var repeatPeriodEnum = {
                daily: 0,
                weekly: 1
            };

            function EventPrototype(appt) {
                var proto = appt;

                this.clone = function() {
                    return $.extend(true, {}, proto);
                };
            }

            function daysBetween(first, second) {
                // Copy date parts of the timestamps, discarding the time parts.
                var one = new Date(first.getFullYear(), first.getMonth(), first.getDate());
                var two = new Date(second.getFullYear(), second.getMonth(), second.getDate());

                // Do the math.
                var millisecondsPerDay = 1000 * 60 * 60 * 24;
                var millisBetween = two.getTime() - one.getTime();
                var days = millisBetween / millisecondsPerDay;

                // Round down.
                return Math.floor(days);
            }

            var shiftEventDate = function(event, newDate) {
                var days = daysBetween(event.start, newDate);

                event.start = $timeUtils.addDays(event.start, days);
                event.end = $timeUtils.addDays(event.end, days);

                event.startInCurrentUserTimezone = $timeUtils.addDays(event.startInCurrentUserTimezone, days);
                event.endInCurrentUserTimezone = $timeUtils.addDays(event.endInCurrentUserTimezone, days);
            };

            var repeatDaily = function(rule, eventPrototype) {
                var events = [],
                    day = new Date(rule.getFromDate()),
                    intervalCounter = rule.repeatInterval,
                    toDateWithOffset = new Date(rule.getToDate());

                while (day <= toDateWithOffset) {
                    if (intervalCounter % rule.repeatInterval === 0) {
                        var event = eventPrototype.clone();
                        shiftEventDate(event, day);
                        if (event.end <= toDateWithOffset) {
                            events.push(event);
                        }
                    }

                    day = $timeUtils.addDays(day, 1);
                    intervalCounter++;
                }

                return events;
            };

            var repeatWeekly = function(rule, eventPrototype) {
                var events = [],
                    day = new Date(rule.getFromDate()),
                    intervalCounter = rule.repeatInterval,
                    repeatDaysOfWeek = rule.repeatOn,
                    toDateWithOffset = new Date(rule.getToDate());


                //Ticket #5988 Repeating appointment should include today's date even if different repeat day.
                var event = eventPrototype.clone();
                if (repeatDaysOfWeek.indexOf(day.getDay() + 1) < 0) {
                    // if repeat days don't include start day
                    events.push(event);
                }

                while (day <= toDateWithOffset) {
                    if (repeatDaysOfWeek.indexOf(day.getDay() + 1) >= 0 && intervalCounter % rule.repeatInterval === 0) {
                        event = eventPrototype.clone();
                        shiftEventDate(event, day);
                        if (event.end <= toDateWithOffset) {
                            events.push(event);
                        }
                    }

                    day = $timeUtils.addDays(day, 1);

                    if (day.getDay() === 0) { //getDay() method returns the day of the week (from 0 to 6). Sunday is 0
                        intervalCounter++;
                    }
                }

                return events;
            };

            var createEventsSeries = function(rule, event) {
                var eventPrototype = new EventPrototype(event);

                var series = [];
                switch (rule.repeatPeriod) {
                    case repeatPeriodEnum.daily:
                        series = repeatDaily(rule, eventPrototype);
                        break;
                    case repeatPeriodEnum.weekly:
                        series = repeatWeekly(rule, eventPrototype);
                        break;
                }

                return series;
            };

            this.createEventsSeries = function(prototype, rule) {
                // we need to change format in order to string-to-Date convertation work correctly in FireFox
                rule.fromDate = $timeUtils.extractDatePartFromSnapDateString(rule.fromDate);
                rule.toDate = $timeUtils.extractDatePartFromSnapDateString(rule.toDate);
                return createEventsSeries(rule, prototype);
            };
        }).singleton();
}(jQuery, snap));
(function($, snap, kendo) {
    "use strict";

    snap.namespace("snap.admin.schedule").use(["snapNotification", "snap.admin.schedule.TimeUtils", "snap.admin.schedule.apptRuleProcessor", "snap.service.availabilityBlockService", "snap.common.schedule.ScheduleCommon", "snap.admin.schedule.AdminScheduleDSFactory"])
        .define("eventService", function($snapNotification, $timeUtils, $apptRuleProcessor, $availabilityBlockService, $scheduleCommon, $adminScheduleDSFactory) {
            var $scope = this;

            var formatErrorMessage = function(error) {
                if (typeof(error) === "undefined" || error === null) {
                    return "Unknown error";
                }

                window.console.error(error);

                var errorMessage;
                if (typeof(error) === 'string') {
                    errorMessage = error;
                } else {
                    if (error.status === 500) {
                        errorMessage = "Internal server error";
                    } else if (error.status === 404) {
                        errorMessage = "Not found";
                    } else if (error.responseText) {
                        errorMessage = error.responseText;
                        try {
                            var parsedMessage = JSON.parse(errorMessage);
                            if (!!parsedMessage.message) {
                                errorMessage = parsedMessage.message;
                            }
                        } catch (e) {

                        }
                    } else {
                        errorMessage = error.statusText;
                    }
                }

                return errorMessage;
            };

            /***************************** Availability Block *********************************/
            function saveAvailabilityBlock(block, maxValidChangeDate) {
                var dfd = $.Deferred();
                saveBlock(block, maxValidChangeDate).done(function(blockResponse) {
                    dfd.resolve(blockResponse);
                }).fail(function(error) {
                    dfd.reject(formatErrorMessage(error));
                });

                return dfd.promise();
            }

            function saveBlock(availabilityBlock, maxValidChangeDate) {
                availabilityBlock.startTime = $timeUtils.dateToString(availabilityBlock.start);
                availabilityBlock.endTime = $timeUtils.dateToString(availabilityBlock.end);
                delete availabilityBlock.start;
                delete availabilityBlock.end;
                if (snap.hospitalSettings.onDemand === false) {
                    availabilityBlock.allowOnDemandAppt = false;
                }
                var errMessage = "This Availability block was changed by someone else. Please reload the page to proceed.";
                if (availabilityBlock.id === 0 || typeof availabilityBlock.id === "undefined" || availabilityBlock.id === null) {
                    return $availabilityBlockService.addAvailabilityBlock(availabilityBlock, availabilityBlock.id);
                } else {
                    var def = $.Deferred();
                    $availabilityBlockService.getSingleAvailabilityBlock(availabilityBlock.id).done(function(resp) {

                        var modifiedTime = new Date(resp.data[0].modifiedDate);
                        if (typeof(resp.data[0].modifiedDate) === "undefined" || modifiedTime < maxValidChangeDate) {
                            $availabilityBlockService.updateAvailabilityBlock(availabilityBlock, availabilityBlock.id).done(function(response) {
                                def.resolve(response);
                            }).fail(function(error) {
                                def.reject(error);
                            });
                        } else {
                            def.reject(errMessage);
                        }
                    }).fail(function() {
                        def.reject(errMessage);
                    });
                    return def.promise();

                }
            }

            function cancelAvailabilityBlock(availabilityBlock) {
                var dfd = $.Deferred();
                var promise = (isEmpty(availabilityBlock.rule) || isEmpty(availabilityBlock.rule.id)) ?
                    $availabilityBlockService.deleteAvailabilityBlock(availabilityBlock.id) :
                    $availabilityBlockService.deleteAvailabilityBlockRule(availabilityBlock.id, availabilityBlock.rule.id);

                promise.done(function() {
                    dfd.resolve();
                }).fail(function(error) {
                    dfd.reject(formatErrorMessage(error));
                });

                return dfd;
            }

            /******************************** Appointment ************************************/
            function saveAppointment(appt, rule) {
                var dfd;

                if (rule) {
                    var apptSeries = $apptRuleProcessor.createEventsSeries(appt, rule);

                    var rmParticipanApptId = function(participant) {
                            participant.appointmentId = null;
                        }
                        //this necessry in case when we update appointment and specified repeat rule.
                    for (var i = 1; i < apptSeries.length; i++) {
                        apptSeries[i].id = 0;

                        apptSeries[i].participants.forEach(rmParticipanApptId);
                    }

                    dfd = saveAppointmentsSeries(apptSeries, apptSeries.length);
                } else {
                    dfd = saveSingleAppointmen(appt);
                }

                return dfd.promise();
            }

            function cancelAppointment(appt) {
                var dfd = $.Deferred();

                $availabilityBlockService.deleteAppointment(appt.id).done(function() {
                    dfd.resolve();
                }).fail(function(error) {
                    dfd.reject(formatErrorMessage(error));
                });

                return dfd;
            }

            function saveSingleAppointmen(appt) {
                var dfd = $.Deferred();

                saveAppt(appt).done(function(appointmentResponse) {
                    dfd.resolve(appointmentResponse); //Success
                }).fail(function(error) {
                    dfd.reject(formatErrorMessage(error));
                });

                return dfd.promise();
            }

            function saveAppointmentsSeries(series, length, dfd, result) {
                if (typeof(dfd) === "undefined") {
                    dfd = $.Deferred();
                }

                if (typeof(result) === "undefined") {
                    result = {
                        total: 0,
                        data: []
                    };
                }

                if (series.length > 0) {
                    var appt = series.shift();

                    saveAppointment(appt).done(function(appointmentResponse) {
                        if (appointmentResponse.data.length) {
                            result.data.push(appointmentResponse.data[0]);
                            result.total++;
                        }
                        saveAppointmentsSeries(series, length, dfd, result);
                    }).fail(function(error) {
                        var startDate = appt.startTime ? $timeUtils.dateFromSnapDateString(appt.startTime) : appt.start;
                        var message = [formatErrorMessage(error), " for appointment at ", kendo.toString(startDate, "dddd, MMMM dd, yyyy h:mm tt"), ". "].join("");
                        $snapNotification.error(message);

                        if (series.length === 0) { // avoids asking for continuation if nothing is left
                            dfd.resolve(result);
                            return;
                        }

                        setTimeout(function() { // <-- this timeout necessary only for correct notifications work.
                            $snapNotification.confirmationWithCallbacks("Do you want to continue to process this appointment series?", function() {
                                saveAppointmentsSeries(series, length, dfd, result);
                            }, function() {
                                dfd.resolve(result); //finish series
                            });

                        }, 500);
                    });
                } else {
                    dfd.resolve(result);
                }

                return dfd.promise();
            }

            function saveAppt(appt) {
                var dfd = $.Deferred();
                if ((appt.end - appt.start) > 86400000) {
                    dfd.reject("Single appointments cannot be longer than 24 hours.");
                } else {
                    getMatchedAvailabilityBlockId(appt).done(function(blockId, isNewBlock) {
                        appt.availabilityBlockId = blockId;
                        appt.startTime = $timeUtils.dateToString(appt.start);
                        appt.endTime = $timeUtils.dateToString(appt.end);
                        appt.where = appt.phoneNumber;
                        appt.whereUse = appt.phoneType;
                        appt.timeZoneId = appt.timeZoneId || snap.profileSession.timeZoneId;
                        appt.zonedTime = {
                            timeZoneId: appt.timeZoneId,
                            startTime: appt.startTime,
                            endTime: appt.endTime
                        };
                        delete appt.start;
                        delete appt.end;
                        delete appt.phoneNumber;
                        delete appt.phoneType;

                        var action = appt.id === 0 ?
                            $availabilityBlockService.addAppointment(appt) :
                            $availabilityBlockService.updateAppointment(appt, appt.id);

                        action.done(function(response) {
                            dfd.resolve(response);
                        }).fail(function(response) {
                            if (isNewBlock) {
                                cancelAvailabilityBlock({ rule: null, id: blockId });
                            }
                            dfd.reject(response);
                        });
                    }).fail(function(error) {
                        dfd.reject(error);
                    });
                }

                return dfd.promise();
            }

            function getMatchedAvailabilityBlockId(appt) {
                var dfd = $.Deferred();

                var clinician = $scheduleCommon.findProvider(appt.participants);

                if (clinician === null) {
                    dfd.reject("Select a provider.");
                    return dfd.promise();
                }


                $adminScheduleDSFactory.getCliniciansDS().selectByPersonId(clinician.personId).done(function(clinician) {
                    if (clinician) {
                        var startDate = appt.startInCurrentUserTimezone || appt.start;
                        var endDate = appt.endInCurrentUserTimezone || appt.end;
                        getBlocksWithTimeInterval(startDate, endDate, clinician.id, true).done(function(blocks) {
                            if (validatePermission(blocks, $scope._blockPermission)) {
                                var block = getBlocksWithMatchedPermission(blocks, $scope._blockPermission);

                                if (block) {
                                    dfd.resolve(block.id);
                                } else {
                                    var message = "Appointment Info: <br /> Start: " +
                                        kendo.toString(startDate, "g") +
                                        "<br /> End: " + kendo.toString(endDate, "g") +
                                        "<br /> <br /> There is no availability block for the selected time period. Do you want to create a block for this appointment?";
                                    // this timeout necessary only for correct notifications work.
                                    window.setTimeout(function() {
                                        $snapNotification.confirmationWithCallbacks(message, function() {
                                            var block = {
                                                id: 0,
                                                start: new Date(startDate),
                                                end: new Date(endDate),
                                                allowOnDemandAppt: false,
                                                allowSelfAppt: appt.appointmentTypeCode === $scheduleCommon.appointmentTypeCode.patientScheduled,
                                                allowProviderAppt: true,
                                                isAvailable: true,
                                                optimizationTypeCodeId: 1,
                                                clinician: {
                                                    clinicianId: clinician.id,
                                                    locked: false,
                                                    private: false
                                                },
                                                rule: null
                                            };

                                            saveAvailabilityBlock(block).done(function(b) {
                                                if (b.data && b.data.length > 0) {
                                                    dfd.resolve(b.data[0].id, true);
                                                } else {
                                                    dfd.reject("Internal error: Cannot find availability block.");
                                                }
                                            }).fail(function(error) {
                                                dfd.reject(error);
                                            });
                                        }, function() {
                                            dfd.reject("This time-slot is currently unavailable.");
                                        });
                                    }, 500);

                                }
                            } else {
                                dfd.reject("You cannot schedule appointment at this time.");
                            }
                        }).fail(function(error) {
                            dfd.reject(error);
                        });
                    } else {
                        dfd.reject("Selected Provider doesn not have permission to create an appointment");
                    }
                }).fail(function() {
                    dfd.reject("Cannot get provider info.");
                });

                return dfd.promise();
            }

            function getBlocksWithTimeInterval(apptStart, apptEnd, clionicianId, getPartial) {
                var dfd = $.Deferred();

                var startDate = new Date(apptStart);
                var endDate = new Date(apptEnd);
                startDate.setMonth(startDate.getMonth() - 1);
                endDate.setMonth(endDate.getMonth() + 1);

                $availabilityBlockService.getAvailabilityBlocks({
                    clinicianIds: [clionicianId],
                    startDate: $timeUtils.dateToString(startDate),
                    endDate: $timeUtils.dateToString(endDate)
                }).done(function(result) {
                    var availabilityBlocks = [];
                    if (result.data) {
                        for (var i = 0; i < result.data.length; i++) {
                            if ($timeUtils.dateFromSnapDateString(result.data[i].startTime) <= apptStart && $timeUtils.dateFromSnapDateString(result.data[i].endTime) >= apptEnd) {
                                availabilityBlocks.push(result.data[i]);
                            }
                        }
                        if (getPartial && availabilityBlocks.length === 0) {
                            for (var j = 0; j < result.data.length; j++) {
                                if ($timeUtils.dateFromSnapDateString(result.data[j].startTime) < apptEnd && $timeUtils.dateFromSnapDateString(result.data[j].endTime) > apptStart) {
                                    availabilityBlocks.push(result.data[j]);
                                }
                            }
                            if (availabilityBlocks.length) {
                                // If thereare partially matched blocks
                                dfd.reject("Your request conflicts with an existing availability block. Try extending an existing block.");
                            } else {
                                dfd.resolve(availabilityBlocks);
                            }
                        } else {
                            dfd.resolve(availabilityBlocks);
                        }
                    } else {
                        dfd.resolve(availabilityBlocks);
                    }
                }).fail(function(error) {
                    dfd.reject(error);
                });

                return dfd.promise();
            }

            function validatePermission(blocks, permission) {
                if (blocks.length > 0) {
                    var block = getBlocksWithMatchedPermission(blocks, permission);
                    return block !== null;
                }

                //If there is no availability block at all than we check current permission level.
                //Admin (allowProviderAppt permission) can create appointments in empty cells (new availability block will be generated).
                return permission === $scheduleCommon.blockPermissions.allowProviderAppt;
            }

            function getBlocksWithMatchedPermission(blocks, permission) {
                var matchedBlock = null;
                blocks.forEach(function(block) {
                    if (block[permission]) {
                        matchedBlock = block;
                    }
                });

                return matchedBlock;
            }

            function saveEncounterDocument(encDoc) {
                var dfd = $.Deferred();

                encDoc.startTime = $timeUtils.dateToString(encDoc.start);
                encDoc.endTime = $timeUtils.dateToString(encDoc.end);
                encDoc.phone = encDoc.phoneNumber;
                encDoc.zonedTime = {
                    timeZoneId: encDoc.timeZoneId,
                    startTime: encDoc.startTime,
                    endTime: encDoc.endTime
                };
                delete encDoc.start;
                delete encDoc.end;
                delete encDoc.phoneNumber;

                $availabilityBlockService.saveEncounterDocument(encDoc).done(function(encounterResponse) {
                    dfd.resolve(encounterResponse); //Success
                }).fail(function(error) {
                    dfd.reject(formatErrorMessage(error));
                });

                return dfd.promise();
            }



            this.setScope = function(blockPermission) {
                this._blockPermission = blockPermission;
            };

            this.saveAvailabilityBlock = function(block, maxValidChangeDate) {
                return saveAvailabilityBlock(block, maxValidChangeDate);
            };

            this.saveAppointment = function(appt, rule) {
                return saveAppointment(appt, rule);
            };

            this.saveEncounterDocument = function(encDoc) {
                return saveEncounterDocument(encDoc);
            };

            this.cancelAvailabilityBlock = function(block) {
                return cancelAvailabilityBlock(block);
            };

            this.cancelAppointment = function(appt) {
                return cancelAppointment(appt);
            };

            this.canAddAppointmentWithTimeInterval = function(clinicianId, apptStart, apptEnd) {
                var dfd = $.Deferred();

                var permission = $scope._blockPermission;
                getBlocksWithTimeInterval(apptStart, apptEnd, clinicianId).done(function(blocks) {
                    dfd.resolve(validatePermission(blocks, permission));
                });

                return dfd.promise();
            };


        });
}(jQuery, snap, kendo));
(function($, snap, kendo, window) {
    "use strict";

    snap.namespace("snap.admin.schedule").use(["snapNotification", "snap.EventAggregator", "snap.common.schedule.ScheduleCommon", "snap.admin.AvailabilityBlockFactory", "snap.service.availabilityBlockService", "snap.admin.schedule.TimeUtils"])
        .define("eventDialog", function($snapNotification, $eventAggregator, $scheduleCommon, $availabilityBlockFactory, $availabilityBlockService, $timeUtils) {
            var
                content = null,
                container = "#popUpContainer",
                currentDialog = null;

            function loadContent(eventVM) {
                var dfd = $.Deferred();

                if (eventVM._type == $scheduleCommon.eventType.availabilityBlock) {
                    $.get("/content/admin/schedule/eventDialog.html" + snap.addVersion, function(data) {
                        content = data;
                        dfd.resolve(content);
                    });
                } else if (eventVM._type == $scheduleCommon.eventType.appointment) {
                    $.get("/content/admin/schedule/apptDialog.html" + snap.addVersion, function(data) {
                        content = data;
                        dfd.resolve(content);
                    });
                } else if (eventVM._type == $scheduleCommon.eventType.documentEncounter) {
                    $.get("/content/admin/schedule/encounterDialog.html" + snap.addVersion, function(data) {
                        content = data;
                        dfd.resolve(content);
                    });
                } else {
                    var error = "Unknown event type";
                    $snapNotification.error(error);
                    throw error;
                }


                return dfd.promise();
            }

            function open(eventVM) {
                close();

                var dfd = $.Deferred();

                setTimeout(function() {
                    loadContent(eventVM).done(function(content) {
                        if ($(container).length === 0) {
                            $("body").append("<div id='popUpContainer'></div>");
                        }

                        var $container = $(container);
                        $container.html(content);

                        if (currentDialog === null) {
                            $container.kendoWindow({
                                actions: [],
                                modal: true,
                                resizable: false,
                                animation: false
                            });

                            $container.parent().addClass('dialogbox-modal');


                            currentDialog = $container.data("kendoWindow");
                        }

                        var $apptEditor = $(container).find("#" + eventVM._type + "_editor");
                        kendo.bind($apptEditor, eventVM);

                        $apptEditor.show();

                        currentDialog.center();
                        currentDialog.open();

                        setTimeout(function() {
                            $('body').addClass("is-viewport-frozen");
                            $apptEditor.find('.dialogbox-master').addClass("is-visible");
                        }, 100);

                        $container.find(".k-grid-header").css('display', 'none');

                        dfd.resolve();
                    });
                }, 200);

                return dfd.promise();
            }

            function close() {
                if (currentDialog) {
                    $snapNotification.hideAllConfirmations();
                    $(container).find('.dialogbox-master').addClass("is-hidden");

                    setTimeout(function() {
                        // currentDialog.close();
                        $('body').removeClass("is-viewport-frozen");
                        currentDialog.destroy();
                        currentDialog = null;
                    }, 200);
                }
            }

            //*********************** EVENTS SUBSCRIPTION ************************/
            [
                "ab_onCloseClick",
                "ab_onRemoveClick",
                "ab_onSubmitClick",
                "appt_onCloseClick",
                "appt_onRemoveClick",
                "appt_onSubmitClick",
                "appt_onReschedule",
                "encDoc_onSubmitClick",
                "encDoc_onCloseClick"

            ].forEach(function(event) {
                $eventAggregator.subscriber(event, function() {
                    close();
                });
            });


            //*********************** PUBLIC METHODS *****************************/
            this.open = function(opt, displayOpt) {
                var dfd = $.Deferred();
                var event = null;

                switch (displayOpt.type) {
                    case $scheduleCommon.eventType.appointment:
                        event = $availabilityBlockFactory.createAppointment(opt, displayOpt);
                        break;
                    case $scheduleCommon.eventType.availabilityBlock:
                        event = $availabilityBlockFactory.createAvailabilityBlock(opt, displayOpt);
                        break;
                    case $scheduleCommon.eventType.documentEncounter:
                        event = $availabilityBlockFactory.createDocumentEncounter(opt, displayOpt);
                        break;
                    default:
                        var error = "Unknown event type";
                        $snapNotification.error(error);
                        throw error;
                }

                event = kendo.observable(event);
                open(event).done(function() {
                    var editor = $("#editor").data("kendoEditor");
                    if (editor) {
                        editor.refresh();
                    }
                    dfd.resolve(event);
                });
                return dfd.promise();
            };

            this.close = function() {
                close();
            };

            this._openAppointmentDialog = function(options, displayOpt) {
                var dfd = $.Deferred();
                this.open(options, displayOpt).done(function(newAppt) {
                    var appt = newAppt;
                    appt.load(options.clinicianId ? [options.clinicianId] : [], displayOpt.userType).done(function() {
                        dfd.resolve(appt);
                    });
                });

                return dfd.promise();
            };

            this.openNewAppointmentDialog = function(dialogOpt) {
                var dfd = $.Deferred();

                var clinicianId = dialogOpt.clinicianId ? parseInt(dialogOpt.clinicianId) : null;
                var patientId = dialogOpt.patientId ? parseInt(dialogOpt.patientId) : null;

                var options = {
                    clinicianId: clinicianId,
                    patientId: patientId
                };
                var displayOpt = {
                    type: $scheduleCommon.eventType.appointment,
                    userType: dialogOpt.userType,
                    forceReadOnly: false
                };

                this._openAppointmentDialog(options, displayOpt).done(function(appt) {
                    dfd.resolve(appt);
                });

                return dfd.promise();
            };

            this.openNewRecordDialog = function(dialogOpt) {
                var dfd = $.Deferred();

                var clinicianId = dialogOpt.clinicianId ? parseInt(dialogOpt.clinicianId) : null;
                var patientId = dialogOpt.patientId ? parseInt(dialogOpt.patientId) : null;

                var options = {
                    clinicianId: clinicianId,
                    patientId: patientId
                };
                var displayOpt = {
                    type: $scheduleCommon.eventType.documentEncounter,
                    userType: dialogOpt.userType,
                    forceReadOnly: false
                };

                this._openAppointmentDialog(options, displayOpt).done(function(appt) {
                    dfd.resolve(appt);
                });

                return dfd.promise();
            };

            this.rescheduleAppointment = function(dialogOpt, userType) {
                var dfd = $.Deferred();

                var clinicianId = dialogOpt.clinicianId ? parseInt(dialogOpt.clinicianId) : null;
                var patientId = dialogOpt.patientId ? parseInt(dialogOpt.patientId) : null;

                var intakeMetadata = dialogOpt.intakeMetadata ? dialogOpt.intakeMetadata : null;
                var waiveFee = dialogOpt.waiveFee ? dialogOpt.waiveFee : false;

                var options = {
                    clinicianId: clinicianId,
                    patientId: patientId,
                    intakeMetadata: intakeMetadata,
                    waiveFee: waiveFee,
                    participants: dialogOpt.participants,
                    phoneNumber: dialogOpt.phoneNumber,
                    phoneType: dialogOpt.phoneType,
                    encounterTypeCode: dialogOpt.encounterTypeCode,
                    serviceTypeId: dialogOpt.serviceTypeId,
                    timeZoneId: dialogOpt.timeZoneId,
                    zonedStart: dialogOpt.zonedStart,
                    zonedEnd: dialogOpt.zonedEnd
                };

                if (dialogOpt.appointmentTypeCode !== $scheduleCommon.appointmentTypeCode.clinicianScheduled) {
                    // to prevent using wrong service type
                    options.serviceTypeId = null;
                }

                var displayOpt = {
                    type: $scheduleCommon.eventType.appointment,
                    userType: userType,
                    forceReadOnly: false
                };

                if (userType === $scheduleCommon.userType.clinician && options.clinicianId && options.clinicianId != snap.profileSession.userId) {
                    // if Provider reschedule appointment of another Provider, we should force change selected clinician
                    options.clinicianId = snap.profileSession.userId;
                    var provider = $scheduleCommon.findProvider(options.participants);
                    if (provider) {
                        options.participants.splice(options.participants.indexOf(provider), 1);
                    }
                }
                this._openAppointmentDialog(options, displayOpt).done(function(appt) {
                    dfd.resolve(appt);
                });

                return dfd.promise();
            };

            this.openExistedAppointmentDialog = function(apptId, type, userType, isDNA) {
                var dfd = $.Deferred();

                var that = this;

                var promise = userType === $scheduleCommon.userType.patient ?
                    $availabilityBlockService.getAppointmentForpatient(apptId) :
                    $availabilityBlockService.getAppointment(apptId);
                promise.done(function(response) {
                    var appt = response.data[0];
                    appt.id = appt.appointmentId;
                    appt.start = $timeUtils.dateFromSnapDateString(appt.startTime);
                    appt.end = $timeUtils.dateFromSnapDateString(appt.endTime);
                    appt.isReschedulable = !!isDNA && userType != $scheduleCommon.userType.patient;
                    appt.phoneNumber = appt.where;
                    appt.phoneType = appt.whereUse;
                    if (appt.zonedTime) {
                        appt.timeZoneId = appt.zonedTime.timeZoneId;
                        appt.zonedStart = $timeUtils.dateFromSnapDateString(appt.zonedTime.startTime);
                        appt.zonedEnd = $timeUtils.dateFromSnapDateString(appt.zonedTime.endTime);
                    }

                    var displayOpt = {
                        type: type,
                        userType: userType,
                        forceReadOnly: !!isDNA
                    };

                    that._openAppointmentDialog(appt, displayOpt).done(function(exstAppt) {
                        dfd.resolve(exstAppt);
                    });
                });

                return dfd.promise();
            };

        }).singleton();
}(jQuery, snap, kendo, window));
//@ sourceURL=itemSelector.control.js

(function($, snap, kendo) {
    "use strict";

    snap.namespace("snap.common").use(["snapNotification", "snap.EventAggregator", "snap.admin.schedule.TimeUtils", "snap.common.schedule.ScheduleCommon", "snap.common.loadingStack", "snap.service.availabilityBlockService", "snap.service.appointmentService", "snap.common.navigationHelper"])
        .define("ItemSelector", function($snapNotification, $eventAggregator, $timeUtils, $scheduleCommon, $loadingStack, $availabilityBlockService, $appointmentService, $navigationHelper) {
            var itemDefaultValues = {
                id: null,
                name: "Select a Person",
                imageSource: "images/default-user.jpg",
                info: "For the list",
            };

            this.events = {
                onItemSelected: "onItemSelected",
                onItemClicked: "onItemClicked",
                onSelectorHide: "onSelectorHide"
            };

            var $scope = this;

            this.personType = {
                clinician: "clinician",
                patient: "patient"
            };

            function sortByName(arr) {
                return arr.sort(function(a, b) {
                    var nameA = a.name.toLowerCase(),
                        nameB = b.name.toLowerCase();

                    if (nameA < nameB) { //sort string ascending
                        return -1;
                    }
                    if (nameA > nameB) {
                        return 1;
                    }

                    return 0; //default return value (no sorting)
                });
            }

            function Item(item, container) {
                this.id = item.id;
                this.name = item.name;
                this.imageSource = item.imageSource ||
                    (item.personType === $scope.personType.clinician ? getDefaultProfileImageForClinician() : getDefaultProfileImageForPatient());
                this.info = item.info;
                this.personType = item.personType;
                this.personId = item.personId;
                this.data = item.data;

                this.isDefault = !this.id;
                this.isSelected = false;
                this.isDisabled = !!item.isDisabled;
                this.isTimeOffsetsVisible = !!item.isTimeOffsetsVisible;
                this.timeZoneId = null;
                this.timeZoneName = "unknown";

                this.vm_TimeText = item.vm_TimeText || "";

                this._convertedTimeCashe = item._convertedTimeCashe || null;

                this.select = function(val) {
                    this.set("isSelected", val);
                };

                this.onSelectClick = function() {
                    if (container) {
                        container.onSelectClick(this);
                    }
                };

                this._clearDeactivationTimeout = function() {
                    if (this._deactivationTimeout) {
                        clearTimeout(this._deactivationTimeout);
                        this.set("isReadOnly", false);
                    }
                };
                $eventAggregator.unSubscribe("itemSelector_onProfileClick");
                    $eventAggregator.subscriber("itemSelector_onProfileClick", function(data) {
                        $navigationHelper.patient.goToPatietProfile({ patientId: data.id });
                    });

                this.onViewProfileClick = function(e) {
                    if (!!this.id) {
                      /*  $eventAggregator.published("itemSelector_onProfileClick", {
                            id: this.id,
                            personType: this.personType
                       });*/
                     /*  var defaultMessage = "Viewing this profile will exit current page. Do you want to proceed?";

                              var message = defaultMessage;
                              sessionStorage.setItem("snap_patientId_ref", this.id);

                              $snapNotification.confirmationWithCallbacks(message, function () {
                                    this._clearDeactivationTimeout();
                                      var patid = sessionStorage.getItem('snap_patientId_ref');
                                     window.location.href = "#/tab/healthinfo/"+patid;
                              });*/
                              if (!!this.id) {
                                  $eventAggregator.published("itemSelector_onProfileClick", {
                                      id: this.id,
                                      personType: this.personType
                                  });
                              }
                              e.preventDefault();
                              return false;
                    }

                };

                this.getValue = function() {
                    return item;
                };

                this.vm_isVisible = function() {
                    if (container) {
                        return !this.isSelected;
                    }

                    return true;
                };

                this.updateTime = function(startTime, endTime, sourceTimeZoneId, useCahedValue) {
                    var that = this;
                    var dfd = $.Deferred();
                    var duration = endTime - startTime;
                    var convertedTimePromise = (useCahedValue && this._convertedTimeCashe) ? dfd.resolve(this._convertedTimeCashe) : this._convertTime(startTime, sourceTimeZoneId);
                    convertedTimePromise.done(function(convertedTime) {
                        if (convertedTime) {
                            that._convertedTimeCashe = convertedTime;
                            var convertedStartTime = $timeUtils.dateFromSnapDateString(convertedTime.convertedDateTime);
                            var timeZoneName = convertedTime.targetTimeZone.abbreviation;
                            var convertedEndTime = new Date(convertedStartTime);
                            convertedEndTime.setTime(convertedEndTime.getTime() + duration);
                            that.timeZoneId = convertedTime.targetTimeZone.id;
                            that.timeZoneName = convertedTime.targetTimeZone.name;
                            that.set("vm_TimeText", kendo.toString(convertedStartTime, "h:mm tt ") + timeZoneName + " - " +
                                kendo.toString(convertedEndTime, "h:mm tt ") + timeZoneName);
                            dfd.resolve();
                        }
                    });
                    return dfd.promise();
                };

                this._convertTime = function(time, sourceTimeZoneId) {
                    var dfd = $.Deferred();
                    if (!time) {
                        dfd.reject();
                    } else {
                        var opt = {
                            dateTime: $timeUtils.dateToString(time),
                            sourceTimeZoneId: sourceTimeZoneId
                        }
                        if (this.personType === $scope.personType.clinician) {
                            opt.targetUserId = this.id;
                        } else {
                            opt.targetPatientId = this.id;
                        }
                        $availabilityBlockService.convertTime(opt).then(function(resp) {
                            dfd.resolve(resp);
                        }, function() {
                            dfd.reject();
                        });
                    }
                    return dfd.promise();
                }
            }

            function Container(opt) {
                this.ds = null;
                this.nameFilter = "";
                this.counterpartFilter = null;
                this.isItemsSelectorVisible = false;
                this.isSelectorLocked = false;
                this.vm_tabindex = opt.tabindex || 1;

                this.selectWithConfirmation = !!opt.selectWithConfirmation;

                this.selectWithConfirmation = !!opt.selectWithConfirmation;

                this.selectedItem = null;
                var scope = this;

                var defaultItem = $.extend(true, {}, itemDefaultValues, opt.defaultItem);
                var triggerEvent = function(name) {
                    var args = Array.prototype.slice.call(arguments).slice(1, arguments.length);
                    var eventCbList = eventList[name];
                    if (eventCbList) {
                        $.each(eventCbList, function() {
                            return this.apply(scope, args);
                        });
                    }
                };

                this.onSelectClick = function(item) {
                    if (this.selectWithConfirmation) {
                        triggerEvent($scope.events.onItemClicked, item);
                    } else {
                        this.selectHandler(item);
                    }
                };

                this.selectHandler = function(item) {
                    this.ds.data().forEach(function(i) {
                        if (i.isSelected) {
                            i.select(false);
                        }
                    });

                    item.select(true);
                    this.selectItem(item);

                    //this._reloadItems();

                    triggerEvent($scope.events.onItemSelected);

                    this.set("isItemsSelectorVisible", false);
                    triggerEvent($scope.events.onSelectorHide);

                    this.trigger("change", { field: "ds" });
                };


                var eventList = {};

                /*********************** PUBLIC API ***********************/
                this.setDataSource = function(ds) {
                    this.set("ds", ds);

                    var that = this;
                    var loadingStack = $loadingStack.newStack(function() {
                        that.set("vm_isItemsLoading", true);
                    }, function() {
                        that.set("vm_isItemsLoading", false);
                    });

                    this.ds.bind("change", function() {
                        that._refresh();
                    });

                    this.ds.bind("requestStart", function() {
                        loadingStack.push();
                    })

                    this.ds.bind("requestEnd", function() {
                        loadingStack.pop();
                    })
                };

                this.getSelectedItem = function() {
                    return this.selectedItem;
                };

                this.isAnyItemSelected = function() {
                    var selectedItem = this.getSelectedItem();
                    return selectedItem !== null;
                };

                this.selectItem = function(item, doNotUpdateTime) {
                    var that = this;
                    this.set("selectedItem", new Item(item));
                    this.selectedItem.select(true);
                    this._refresh();
                    if (!doNotUpdateTime) {
                        this.selectedItem.updateTime(this._startTime, this._endTime, this._timeZoneId).done(function() {
                            that._refresh();
                        });
                    }

                };

                this.setEventTime = function(start, end, timeZoneId) {
                    this._startTime = start;
                    this._endTime = end;
                    this._timeZoneId = timeZoneId;
                };

                this.updateEventTime = function(start, end, timeZoneId, useCahedValue) {
                    var that = this;
                    this.setEventTime(start, end, timeZoneId);
                    if (this.selectedItem) {
                        this.selectedItem.updateTime(this._startTime, this._endTime, this._timeZoneId, useCahedValue).done(function() {
                            that._refresh();
                        });
                    }
                };

                this.showTimeOffset = function(value) {
                    if (this.selectedItem) {
                        this.selectedItem.set("isTimeOffsetsVisible", value);
                        this._refresh();
                    }
                };

                this.refresh = function() {
                    this._reloadItems();
                };

                //We need event subscription because we can not not use Kendo Observable in constructor.
                //And use var scope = this; scope.set("...", ...)
                this.on = function(eventName, cb) {
                    var eventCbList = eventList[eventName];
                    if (!eventCbList) {
                        eventCbList = [];
                    }
                    eventCbList.push(cb);
                    eventList[eventName] = eventCbList;
                };

                /*********************** MVVM BINDINGS ***********************/
                this.vm_isItemsLoading = false;

                this.vm_nameFilterChange = function() {
                    if (!!this.searchTimeout) {
                        clearTimeout(this.searchTimeout);
                    }
                    var that = this;
                    this.searchTimeout = setTimeout(function() {
                        that.ds.read({
                            skip: 0
                        });
                    }, 500);
                };

                this.vm_isItemsListEmpty = function() {
                    return this.ds.data().length === 0;
                };

                this.vm_getItemsListEmptyNotification = function() {
                    return this.nameFilter === "" ?
                        "Enter user name to begin search" :
                        "No users match your search";
                };

                this.vm_getSelectedItemOrDefault = function() {
                    if (this.selectedItem) {
                        var selected = kendo.observable(new Item(this.selectedItem));
                        selected.set("isSelectorLocked", this.isSelectorLocked);
                        return selected;
                    } else {
                        var def = defaultItem;
                        if (opt.defaultItem) {
                            def = opt.defaultItem;
                        }

                        return kendo.observable(new Item(def));
                    }
                };

                this.vm_isSelectedItemsListNotEmpty = function() {
                    return this.vm_getSelectedItems().length > 0;
                };

                this.vm_getSelectedItems = function() {
                    var arr = [];

                    if (this.selectedItem) {
                        arr.push(this.selectedItem);
                    }
                    return arr;
                };

                this.vm_openItemsSelector = function(e) {
                    if (e) {
                        e.preventDefault();
                    }
                    if (!this.isSelectorLocked) {
                        var that = this;
                        that.set("isItemsSelectorVisible", true);

                        window.setTimeout(function() {
                            $(".directory.is-active").find(".nameFilterField").focus();
                        }, 500);
                    }
                };

                this.vm_hideItemsSelector = function(e) {
                    e.preventDefault();
                    this.set("isItemsSelectorVisible", false);
                    triggerEvent($scope.events.onSelectorHide);
                };

                /************************ PRIVATE METHODS ************************/
                this._reloadItems = function() {
                    var that = this;
                    this.ds.read({ skip: 0 }).done(function() {
                        that._refresh();

                        window.setTimeout(function() {
                            $(".directory.is-active").find(".nameFilterField").focus();
                        }, 500);
                    });
                };

                this._refresh = function() {
                    this.trigger("change", {
                        field: "vm_getSelectedItems"
                    });
                    this.trigger("change", {
                        field: "vm_getSelectedItemOrDefault"
                    });

                    this.trigger("change", {
                        field: "vm_isItemsListEmpty"
                    });
                    this.trigger("change", {
                        field: "vm_getItemsListEmptyNotification"
                    });

                    this.trigger("change", {
                        field: "vm_isSelectedItemsListNotEmpty"
                    });
                };

                this.disableSelectedItem = function() {
                    if (this.selectedItem) {
                        this.selectedItem.set("isDisabled", true);
                        this.trigger("change", {
                            field: "vm_getSelectedItemOrDefault"
                        });
                    }
                };
            }

            //************************* Data sources **************************
            function createCliniciansDS(container) {
                return new kendo.data.DataSource({
                    batch: true,
                    transport: {
                        read: {
                            url: [snap.baseUrl + "/api/v2.1/providers", snap.hospitalSession.hospitalId, "clinicians"].join("/"),
                            dataType: "json",
                            contentType: 'application/json',
                            type: "get"
                        },
                        parameterMap: function(data, type) {
                            if (type !== "read") {
                                return JSON.stringify({
                                    data: data.models
                                });
                            } else {
                                if (container.nameFilter) {
                                    data.search = container.nameFilter;
                                }
                                if (container.counterpartFilter) {
                                    data.patient = container.counterpartFilter;
                                }
                                data.roleFunctions = [snap.security.conduct_virtual_consultations].join(",")
                                return data;
                            }
                        }
                    },
                    error: function(e) {
                        $scheduleCommon.handleDataSourceError(e, "Provider list");
                    },
                    schema: {
                        data: function(clinicians) {
                            var data = clinicians.data.map(function(clinician) {
                                clinician.person.providerId = clinician.providerId;
                                return new Item({
                                    id: clinician.userId,
                                    personId: clinician.person.id,
                                    name: $scheduleCommon.getFullName(clinician.person),
                                    imageSource: clinician.person.photoUrl || getDefaultProfileImageForClinician(),
                                    info: $scheduleCommon.getPhoneNumber(clinician.person),
                                    data: clinician,
                                    personType: $scope.personType.clinician,
                                }, container);
                            });

                            if (container.selectedItem) {
                                data.forEach(function(item) {
                                    if (item.personId === container.selectedItem.personId) {
                                        item.isSelected = true;
                                    }
                                });
                            }

                            return data;
                        },
                        total: "total",
                    },
                    pageSize: 30,
                    serverPaging: true
                });
            }

            function createPatientsDS(container) {
                return new kendo.data.DataSource({
                    batch: true,
                    transport: {
                        read: {
                            url: [snap.baseUrl + '/api/v2.1/providers/', snap.hospitalSession.hospitalId, '/patients'].join(''),
                            dataType: "json",
                            contentType: 'application/json',
                            type: "get"
                        },
                        parameterMap: function(data, type) {
                            if (type !== "read") {
                                return JSON.stringify({
                                    data: data.models
                                });
                            } else {
                                if (container.nameFilter) {
                                    data.search = container.nameFilter;
                                }
                                if (container.counterpartFilter) {
                                    data.clinician = container.counterpartFilter;
                                }

                                return data;
                            }
                        }
                    },
                    error: function(e) {
                        $scheduleCommon.handleDataSourceError(e, "Patients list");
                    },
                    schema: {
                        data: function(patients) {
                            var data = patients.data.map(function(patient) {
                                patient.person.providerId = patient.providerId;
                                return new Item({
                                    id: patient.patientId,
                                    personId: patient.person.id,
                                    name: $scheduleCommon.getFullName(patient.person),
                                    imageSource: patient.person.photoUrl || getDefaultProfileImageForPatient(),
                                    info: $scheduleCommon.getPhoneNumber(patient.person),
                                    data: patient,
                                    personType: $scope.personType.patient,
                                }, container);
                            });

                            if (container.selectedItem) {
                                data.forEach(function(item) {
                                    if (item.personId === container.selectedItem.personId) {
                                        item.isSelected = true;
                                    }
                                });
                            }

                            return data;
                        },
                        total: "total",
                    },
                    pageSize: 30,
                    serverPaging: true
                });
            }

            function createFamilyGroupDS(container) {
                return new kendo.data.DataSource({
                    batch: true,
                    transport: {
                        read: {
                            url: snap.baseUrl + "/api/v2.1/patients/authorized-patients",
                            dataType: "json",
                            contentType: 'application/json',
                            type: "get"
                        },
                        parameterMap: function(data, type) {
                            if (type !== "read") {
                                return JSON.stringify({
                                    data: data.models
                                });
                            } else {
                                if (container.nameFilter) {
                                    data.search = container.nameFilter;
                                }

                                if (container.counterpartFilter) {
                                    data.providerPersonId = container.counterpartFilter;
                                }

                                return data;
                            }
                        }
                    },
                    error: function(e) {
                        $scheduleCommon.handleDataSourceError(e, "Patients list");
                    },
                    schema: {
                        data: function(patients) {
                            var data = patients.data.map(function(patient) {
                                patient.person.providerId = patient.providerId;
                                return new Item({
                                    id: patient.patientId,
                                    personId: patient.person.id,
                                    name: $scheduleCommon.getFullName(patient.person),
                                    imageSource: patient.person.photoUrl || getDefaultProfileImageForPatient(),
                                    info: $scheduleCommon.getPhoneNumber(patient.person),
                                    data: patient,
                                    personType: $scope.personType.patient,
                                }, container);
                            });

                            if (container.selectedItem) {
                                data.forEach(function(item) {
                                    if (item.personId === container.selectedItem.personId) {
                                        item.isSelected = true;
                                    }
                                });
                            }

                            return data;
                        },
                        total: "total",
                    },
                    pageSize: 30,
                    serverPaging: true
                });
            }

            /************************ "STATIC" METHODS ************************/
            this.containerClass = Container;

            this.emptySelector = function(opt) {
                var c = kendo.observable(new Container(opt));
                c.setDataSource(new kendo.data.DataSource({ data: [] }));

                return c;
            };

            this.patientsSelector = function(opt) {
                opt.tabindex = 1;
                var c = kendo.observable(new Container(opt));
                var ds = createPatientsDS(c);
                c.setDataSource(ds);

                return c;
            };

            this.cliniciansSelector = function(opt) {
                opt.tabindex = 2;
                var c = kendo.observable(new Container(opt));
                var ds = createCliniciansDS(c);
                c.setDataSource(ds);

                return c;
            };

            this.familyGroupSelector = function(opt) {
                opt.tabindex = 1;
                var c = kendo.observable(new Container(opt));
                var ds = createFamilyGroupDS(c);
                c.setDataSource(ds);

                return c;
            };

            // this.cliniciansSelector = function(opt) {
            //     return patientsSelector(opt)
            // }

            this.convertPersonToSelectorItem = function(person, id, personType, speciality) {
                var item = {
                    id: id || null,
                    personId: person.id,
                    name: $scheduleCommon.getFullName(person),
                    imageSource: person.photoUrl || (personType === $scope.personType.patient ? getDefaultProfileImageForPatient() : getDefaultProfileImageForClinician()),
                    data: {
                        person: person
                    },
                    personType: personType,
                };

                if (personType === $scope.personType.patient) {
                    item.info = $scheduleCommon.getPhoneNumber(person);
                } else {
                    item.info = $scheduleCommon.getSpeciality(speciality);
                }

                return item;
            };

        }).singleton();
}(jQuery, snap, kendo));

//@ sourceURL=timeUtils.js

(function($, snap) {
    "use strict";
    snap.namespace("snap.admin.schedule").use([])
        .define("TimeUtils", function() {
            this.addDays = function(date, days) {
                var result = new Date(date);
                result.setDate(result.getDate() + days);
                return result;
            };

            this.addMinutes = function(date, minutes) {
                return new Date(date.getTime() + minutes * 60000);
            };

            /********************** SnapTime format: "2016-04-05T14:00:00+02:00" *********************************/
            this.extractDatePartFromSnapDateString = function(snapDateString) {
                return snapDateString.slice(0, 19) + "Z"; //we need 'Z' in order to have the same data in Chrome and FF.
            };

            this.dateFromSnapDateString = function(snapDateString) {
                var year = snapDateString.slice(0, 4); // - 1900;
                var month = snapDateString.slice(5, 7) - 1;
                var day = snapDateString.slice(8, 10);
                var hours = snapDateString.slice(11, 13);
                var min = snapDateString.slice(14, 16);
                return new Date(year, month, day, hours, min);
            };

            this.dateToString = function(snapDateObject) {
                var year = snapDateObject.getFullYear();
                var month = ('0' + (snapDateObject.getMonth() + 1)).slice(-2);
                var day = ('0' + snapDateObject.getDate()).slice(-2);
                var hours = ('0' + snapDateObject.getHours()).slice(-2);
                var min = ('0' + snapDateObject.getMinutes()).slice(-2);
                return year + '-' + month + '-' + day + 'T' + hours + ':' + min;
            };

            this.parseTimeInterval = function(timeIntervalInSeconds) {
                // does the same job as parseInt truncates the float
                var hours = (timeIntervalInSeconds / 3600) | 0;
                var minutes = ((timeIntervalInSeconds % 3600) / 60) | 0;
                var seconds = (timeIntervalInSeconds % 60) | 0;

                return {
                    original: {
                        hours: hours,
                        minutes: minutes,
                        seconds: seconds,
                    },
                    formatted: {
                        hours: hours < 10 ? "0" + hours : hours,
                        minutes: minutes < 10 ? "0" + minutes : minutes,
                        seconds: seconds < 10 ? "0" + seconds : seconds,
                    },
                    toString: function() {
                        return [this.formatted.hours, this.formatted.minutes, this.formatted.seconds].join(":");
                    }
                };
            };

        }).singleton();
}(jQuery, window.snap = window.snap || {}));
(function($, snap, kendo) {
    "use strict";

    snap.namespace("snap.common.schedule").use(["snapNotification"])
        .define("ScheduleCommon", function($snapNotification) {

            /************************ START Timezone ***************************/
            //This functionality check that we have timeZoneSystemId.
            //If not, then we get timeZoneSystemId from "/api/v2/admin/userstaffprofile" api.
            if (isEmpty(snap.userSession.timeZoneSystemId)) {
                window.console.warn("snap.userSession.timeZoneSystemId is undefined.");

                $.ajax({
                    type: "GET",
                    url: snap.baseUrl + "/api/v2.1/users/current-time",
                    contentType: "application/json; charset=utf-8",
                    dataType: "json",
                }).done(function(response) {
                    var timeZone = response.message;
                    snap.userSession.timeZoneSystemId = timeZone;
                    snap.updateSnapJsSession("snap_user_session", "timeZoneSystemId", timeZone);
                }).fail(function() {
                    $snapNotification.error("Error. Time zone info missied");
                });
            }
            /************************ END Timezone ***************************/

            this.findParticipant = function(participants, participantTypeCode) {
                if (participants) {
                    for (var j = 0; j < participants.length; j++) {
                        if (participants[j] && participants[j].participantTypeCode === participantTypeCode && (typeof participants[j].status === "undefined" || participants[j].status === 1)) {
                            return participants[j];
                        }
                    }
                }

                return null;
            };

            this.findProvider = function(participants) {
                return this.findParticipant(participants, this.participantTypeCode.practicioner);
            };

            this.findPatient = function(participants) {
                return this.findParticipant(participants, this.participantTypeCode.patient);
            };

            this.getFullName = function(person) {
                var fullName = "";
                if (person && person.name) {
                    var nameParts = [];

                    if (!!person.name.given) {
                        nameParts.push(person.name.given);
                    }

                    if (!!person.name.family) {
                        nameParts.push(person.name.family);
                    }

                    fullName = nameParts.join(" ");
                }

                return fullName;
            };

            this.getPhoneNumber = function(person) {
                var phoneTypesPriority = ["home", "work", "other", "old", "temp"];

                if (person && person.phones && person.phones.length) {
                    var phones = person.phones;
                    for (var i = 0; i < phoneTypesPriority.length; i++) {
                        for (var j = 0; j < phones.length; j++) {
                            if (phones[j].use === phoneTypesPriority[i] && $.trim(phones[j].value) !== "") {
                                return phones[j].value;
                            }
                        }
                    }
                    return person.phones[0].value;
                }
                return "";
            };

            this.getSpeciality = function(speciality) {
                if (!isEmpty(speciality)) {
                    var arr = [];

                    if (!!speciality.primary) {
                        arr.push(speciality.primary);
                    }

                    if (!!speciality.secondary) {
                        arr.push(speciality.secondary);
                    }

                    return arr.join(" | ");
                } else return "";
            };

            this.attendenceCode = {
                unknown: 0,
                required: 1,
                optional: 2,
                cancelled: 3
            };

            this.participantTypeCode = {
                none: 0,
                patient: 1,
                practicioner: 2,
                relatedPerson: 3
            };

            this.userType = {
                admin: 0,
                clinician: 1,
                patient: 2
            };

            this.appointmentTypeCode = {
                none: 0,
                clinicianScheduled: 1,
                onDemand: 2,
                patientScheduled: 3
            };

            this.blockPermissions = {
                allowOnDemandAppt: "allowOnDemandAppt",
                allowSelfAppt: "allowSelfAppt",
                allowProviderAppt: "allowProviderAppt",
            };

            this.eventType = {
                availabilityBlock: "availabilityBlock",
                appointment: "appointment",
                documentEncounter: "documentEncounter"
            };
            this.appointmentStatusCode = {
                notSpecified: 0,
                scheduled: 1,
                waiting: 2,
                cancelledByPatient: 3,
                cancelledByProvider: 4,
                fulfilled: 5,
                transferred: 6
            };
            this.appointmentStatus = {
                notSpecified: "NotSpecified",
                scheduled: "Scheduled",
                waiting: "Waiting",
                cancelledByPatient: "CancelledByPatient",
                cancelledByProvider: "CancelledByProvider",
                fulfilled: "Fulfilled",
                transferred: "Transferred"
            };

            this.concernCodes = {
                otherPrimary: -1,
                otherSecondary: -2
            };
            this.isAppointmentFulfilled = function(status) {
                if (typeof(status) === "string") {
                    return status === this.appointmentStatus.fulfilled;
                }
                return status === this.appointmentStatusCode.fulfilled;
            }
            this.isAppointmentReadOnly = function(status) {
                if (typeof(status) === "string") {
                    return [this.appointmentStatus.scheduled, this.appointmentStatus.transferred].indexOf(status) === -1;
                }
                return [this.appointmentStatusCode.scheduled, this.appointmentStatusCode.transferred].indexOf(status) === -1;
            };
            this.isAppointmentInWaiting = function(status) {
                if (typeof(status) === "string") {
                    return status === this.appointmentStatus.waiting;
                }
                return status === this.appointmentStatusCode.waiting;
            };

            this.handleDataSourceError = function(e, dsName) {
                if (!snap.isUnloading) {
                    var errorMessage = dsName + " error. ";
                    if (e.errorThrown === "Unauthorized") {
                        errorMessage = ["You do not have role functions for viewing ", dsName, "."].join("");
                    } else if (e.xhr.readySate !== 4) {
                        errorMessage = ["Cannot read ", dsName, ". Please check your internet connection"].join("");
                    } else if (typeof e.errorThrown != "undefined") {
                        errorMessage = errorMessage + e.errorThrown;
                    }

                    $snapNotification.error(errorMessage);
                }
            }
        }).singleton();
}(jQuery, snap, kendo));
//@ sourceURL=multiselectControl.js

(function($, snap, kendo) {
    "use strict";

    snap.namespace("snap.common")
        .define("multiselectControl", function() {
            var $control = this;

            var popupMinHeight = "42px";

            this.events = {
                itemAdded: "multiselectControl_itemAdded",
                matchItemsLengthChanged: "multiselectControl_matchItemsLengthChanged",
                selectedItemChanged: "multiselectControl_selectedItemChanged"
            };

            function MultiselectControl(opt) {
                var _itemConstructor = opt.constructor;

                var $scope = this,
                    selectedItems = [],
                    eventList = {};


                var triggerEvent = function(name) {
                    var args = Array.prototype.slice.call(arguments).slice(1, arguments.length);
                    var eventCbList = eventList[name];
                    if (eventCbList) {
                        $.each(eventCbList, function() {
                            return this.apply($scope, args);
                        });
                    }
                };
                this.on = function(eventName, cb) {
                    var eventCbList = eventList[eventName];
                    if (!eventCbList) {
                        eventCbList = [];
                    }
                    eventCbList.push(cb);
                    eventList[eventName] = eventCbList;
                };

                this.selectedItem = null;
                this.vm_noResults = false;
                this.dataSource = opt.dataSource || [];

                this._popup = null;
                this._header = null;

                var itemSelected = function(item) {
                    var index = snap.util.findIndex(selectedItems, "id", item.id);
                    return index >= 0;
                };

                this.createFilteringDataSource = function(dataUrl, dataIdField, dataReadFilter) {
                    var doMakeFilter = dataReadFilter && dataReadFilter.call;
                    var idFieldName = dataIdField || "id";
                    this.dataSource = new kendo.data.DataSource({
                        serverFiltering: true,
                        transport: {
                            read: {
                                url: dataUrl,
                                dataType: "json"
                            },
                            parameterMap: function(data, type) {
                                if (doMakeFilter && type === "read") {
                                    return new dataReadFilter(data.filter);
                                }
                            }
                        },
                        schema: {
                            data: function(response) {
                                var data = response.data.filter(function(item) {
                                    return !itemSelected(item);
                                });
                                $scope.set("vm_noResults", data.length === 0);
                                triggerEvent($control.events.matchItemsLengthChanged, { data: data.length });
                                return data;
                            },
                            id: idFieldName
                        }
                    });
                };

                var unselectItem = function(item) {
                    var index = snap.util.findIndex(selectedItems, "id", item.id);
                    if (index >= 0) {
                        selectedItems.splice(index, 1);
                    }
                };

                this.addItem = function(item) {
                    selectedItems.push(item);
                    $scope.refreshItems();
                    triggerEvent($control.events.itemAdded, { data: item });
                };

                this.load = function() {
                    $scope = this;
                };

                this.vm_selectedItems = function() {
                    var convertedItems = [];
                    selectedItems.forEach(function(item) {
                        var el = new _itemConstructor(item, function() {
                            unselectItem(el);
                            $scope.refreshItems();
                        });
                        el = kendo.observable(el);
                        convertedItems.push(el);
                    });
                    return convertedItems;
                };

                this.containsBy = function(field, fieldName) {
                    return snap.util.findIndex(selectedItems, fieldName, field) >= 0;
                };

                this.getSelectedItems = function() {
                    return selectedItems.slice();
                };

                this.refreshItems = function() {
                    this.trigger("change", { field: "vm_selectedItems" });
                };

                this.vm_onChangeSelectedItem = function() {
                    if (typeof this.selectedItem === "object") {
                        this.addItem(this.selectedItem);
                    }
                    this.set("selectedItem", null);
                    this.set("vm_noResults", false);
                    triggerEvent($control.events.selectedItemChanged, { data: this.selectedItem });
                };

                this.initNoDataMessage = function(kendoAutoComplete) {
                    // it implements using header template to emulate noDataTemplate work
                    // this fix was made because kendo noDataTemplate does not work
                    // if you don't invoke this method multiselect works as usual without showing noData message

                    if (kendoAutoComplete.popup && kendoAutoComplete.header) {
                        this._kendoAutoComplete = kendoAutoComplete;
                        this._popup = kendoAutoComplete.popup;
                        this._header = kendoAutoComplete.header;

                        this._popup.bind("close", function(e) {
                            if ($scope.vm_noResults) {
                                // prevent closing
                                e.preventDefault();
                            }
                        });

                        this.on($control.events.matchItemsLengthChanged, function(e) {
                            var dataLength = e.data;
                            if (dataLength) {
                                // hide noData message
                                $scope._header.hide();
                            } else {
                                // show noData message and open popup if it is closed
                                $scope._header.show();

                                // adjust size
                                $scope._kendoAutoComplete.list.css("height", popupMinHeight);
                                $scope._popup.wrapper.css("height", popupMinHeight);

                                if (!$scope._popup.visible()) {
                                    $scope._popup.open();
                                }
                            }
                        });

                        this.on($control.events.selectedItemChanged, function() {
                            // when we select item or just leave input, hide noData message and close popup
                            $scope._popup.close();
                            $scope._header.hide();
                        });
                    }
                };
            }

            this.createNew = function(opt) {
                var control = kendo.observable(new MultiselectControl(opt));
                control.load();
                return control;
            };

        }).singleton();

}(jQuery, snap, kendo));

/// <reference path="../core/snap.core.js" />
/// <reference path="../core/snapHttp.js" />
/// <reference path="../jquery-2.1.3.js" />


;
(function($, snap) {

    "use strict";

    snap.namespace("snap.service").using(["snapHttp"]).define("appointmentService", function($http) {
        this.getAppointment = function(id) {
            return $http.get([snap.baseUrl, "/api/v2/physicians/appointments/", id, '/all'].join(""));
        };

        this.getAppointments = function(data) {
            return $http.get([snap.baseUrl, "/api/v2/admin/consultations"].join(""), data);
        };
        this.getVideoKey = function(id) {
            return $http.get([snap.baseUrl, "/api/v2/physicians/appointments/", id, "/videokey"].join(""));
        };

        this.saveSoapData = function(data) {
            var url = [snap.baseUrl, "/api/v2/physicians/soapnotes"].join("");
            return $.ajax({
                url: url,
                type: "POST",
                contentType: "application/json; charset=utf-8",
                dataType: "json",
                data: JSON.stringify(data)
            });

        };

        this.getParticipants = function(consulationId) {
            var url = [snap.baseUrl, "/api/v2/patients/consultations/", consulationId, "/participants"].join("");
            return $.ajax({
                url: url,
                type: "GET",
                contentType: "application/json; charset=utf-8"
            });
        };
        this.saveMedicalCodeForConsultation = function(data) {
            var url = [snap.baseUrl, "/api/v2/physicians/consultation/medicalcodes"].join("");
            return $.ajax({
                url: url,
                type: "POST",
                contentType: "application/json; charset=utf-8",
                dataType: "json",
                data: JSON.stringify(data)
            });

        };

        this.getConsultation = function(id) {
            return $http.get([snap.baseUrl, "/api/v2.1/clinicians/consultations/", id].join(""));
        };

        this.getConsultationById = function(id) {
            return $http.get([snap.baseUrl, "/api/v2/patients/consultations/", id, "/all"].join(""));
        };
        this.getPatientInformationByConsultationId = function(id) {
            return $http.get([snap.baseUrl, "/api/v2/patients/consultations/", id, "/patientprofile"].join(""));
        };
        this.getCptCodes = function() {
            return $http.get([snap.baseUrl, "/api/v2/CptCodes"].join(""));
        };
        this.getHospitalMedicaCodingConfiguration = function(consultationId) {
            return $http.get([snap.baseUrl, "/api/v2/physicians/medicalcodingsconfiguration/", consultationId].join(""));
        };
        this.getPhysicianInformation = function(id) {
            return $http.get([snap.baseUrl, "/api/v2/Physicians/", id].join(""));
        };
        this.getConsultationDetails = function(consultationId) {
            return $http.get([snap.baseUrl, "/api/reports/consultationreportdetails/", consultationId].join(""));
        };
        this.getConsultationChartNotes = function(consultationId, meetingTypeCode) {
            return $http.get([snap.baseUrl, "api/reports/consultationreportdetails/chatnote", consultationId, meetingTypeCode].join("/"));
        };

        this.fullfillappointment = function(consultationId) {
            return $http.post([snap.baseUrl, "/api/v2.1/clinicians/consultations/", consultationId, "/markasfullfill"].join(""));
        };

        this.setAppointmentFlag = function(appointmentId, flag) {
            var url = [snap.baseUrl, "/api/v2.1/clinician/appointments/", appointmentId, "/flag"].join("");
            return $.ajax({
                url: url,
                type: "PUT",
                contentType: "application/json; charset=utf-8",
                dataType: "text json",
                data: JSON.stringify({ Flag: flag })
            });
        };

        this.dismissAppointment = function(appointmentId, dismissReasonId) {
            var url = [snap.baseUrl, "/api/v2.1/appointments/", appointmentId, "/dismiss"].join("");
            return $.ajax({
                url: url,
                type: "POST",
                contentType: "application/json; charset=utf-8",
                dataType: "json",
                data: JSON.stringify({ DismissReasonId: dismissReasonId })
            });
        };

        this.updateConsultationStatus = function(consultationId, updateStatusId) {
            var url = [snap.baseUrl, "/api/v2.1/clinicians/consultations/", consultationId, "/status"].join("");
            return $.ajax({
                url: url,
                type: "POST",
                contentType: "application/json; charset=utf-8",
                dataType: "json",
                data: JSON.stringify({ ConsultationStatusId: updateStatusId })
            });
        };

        this.getPhysicianActiveConsultations = function() {
            return $http.get([snap.baseUrl, "/api/v2/physicians/consultations/activeconsultations"].join(""));
        };

        this.getPhysicianActiveOpenConsultations = function() {
            return $http.get([snap.baseUrl, "/api/v2/physicians/consultations/activeopenconsultations"].join(""));
        };


        this.clinicianEndActiveConsultaion = function(consulationId) {
            var url = [snap.baseUrl, "/api/v2/physicians/consultations/activeconsultations/", consulationId].join("");
            return $.ajax({
                url: url,
                type: "DELETE",
                contentType: "application/json; charset=utf-8"
            });
        };

        this.clinicianEndActiveOpenConsultaion = function(meetingId) {
            var url = [snap.baseUrl, "/api/v2/physicians/consultations/activeopenconsultations/", meetingId].join("");
            return $.ajax({
                url: url,
                type: "DELETE",
                contentType: "application/json; charset=utf-8"
            });
        };


        this.patientEndActiveConsultaion = function(consulationId) {
            var url = [snap.baseUrl, "/api/v2/patients/activeconsultations/", consulationId].join("");
            return $.ajax({
                url: url,
                type: "DELETE",
                contentType: "application/json; charset=utf-8"
            });
        };

        this.loadChatHistory = function(consulationId) {
            return $http.get([snap.baseUrl, "api/consultations", consulationId, "chat"].join("/"));
        };

        this.loadPreConsultationChatHistory = function(consulationId) {
            return $http.get([snap.baseUrl, "api/consultations", consulationId, "preconsultation-chat"].join("/"));
        };
        this.notifyProviders = function(appointmentId, request) {
            var url = ["/api/v2.1/clinician/appointments/", appointmentId, "/notifications"].join("");

            return $.ajax({
                url: url,
                type: "POST",
                contentType: "application/json; charset=utf-8",
                dataType: "json",
                timeout: 60000,
                data: JSON.stringify(request)
            });
        };
    }).singleton();

}(jQuery, window.snap = window.snap || {}));


;
(function(global, $) {
    snap.namespace("snap.hub").use(["snap.hub.hubModel"])
        .define("consultationsListingHub", function($hubModel) {
            var consultationsListingHub = $.connection.consultationsListingHub,
                scope = this,
                isStarted = false,
                isInitialized = false;

            $hubModel._initModel(consultationsListingHub, this);

            var initConnection = function() {
                $.connection.hub.qs = $.connection.hub.qs || {};
                if (snap.userSession && snap.userSession.token) {
                    $.connection.hub.qs["Bearer"] = snap.userSession.token;
                }
            };

            this.init = function() {
                if (isInitialized) {
                    window.console.log("consultationsListingHub was initialized before");
                    return;
                }
                isInitialized = true;

                scope.on("refreshConsultationsListings", function() {
                    window.console.log("consultationsListingHub: Refresh consultations listings");
                });
                scope.on("start", function() {
                    isStarted = true;
                    window.console.log("consultationsListingHub started");
                });

                consultationsListingHub.client = {};
                consultationsListingHub.client.refreshConsultationsListings = function() {
                    scope.triggerEvent("refreshConsultationsListings");
                };

                initConnection();
            };

            this.isHubStarted = function() {
                return isStarted;
            };

            this.isHubInitialized = function() {
                return isInitialized;
            };

            this.markAsStarted = function(value) {
                isStarted = !!value;
            };

            this.refresh = function() {
                return consultationsListingHub.server.refresh();
            };

            this.getConsultationsInfo = function(data) {
                return consultationsListingHub.server.getConsultationsInfo(data);
            };

            this.getConsultationsInfoForPatient = function() {
                return consultationsListingHub.server.getConsultationsInfoForPatient(data);
            };

        }).singleton();
})(window, jQuery);

;
(function(global, $) {
    snap.namespace("snap.hub").use(["snap.hub.hubModel"])
        .define("creditHub", function($hubModel) {
            var creditHub = $.connection.creditHub,
                scope = this,
                isStarted = false,
                isInitialized = false;

            $hubModel._initModel(creditHub, this);

            var initConnection = function() {
                $.connection.hub.qs = $.connection.hub.qs || {};
                if (snap.userSession && snap.userSession.token) {
                    $.connection.hub.qs["Bearer"] = snap.userSession.token;
                }
            };

            this.init = function(isCustomer) {
                if (isInitialized) {
                    window.console.log("creditHub was initialized before");
                    return;
                }
                isInitialized = true;

                scope.on("start", function() {
                    isStarted = true;
                    window.console.log("creditHub started");
                });

                creditHub.client = {
                    onCreditChanged: function() {
                        scope.triggerEvent("onCreditChanged");
                    }
                };

                initConnection();
            };

            this.isHubStarted = function() {
                return isStarted;
            };

            this.isHubInitialized = function() {
                return isInitialized;
            };

            this.markAsStarted = function(value) {
                isStarted = !!value;
            };

        }).singleton();
})(window, jQuery);

//@ sourceURL=contentLoader.js

"use strict";
(function($, snap, kendo, global) {

    snap.namespace("snap.common").use([])
        .define("contentLoader", function() {


            this.bindViewModel = function(vm, containerId, path) {
                return snap.cachedGetHtml(path)
                    .then(function(content) {
                        var $container = $(containerId);
                        $container.html(content);
                        kendo.bind($container, vm);
                        return vm;
                    });
            };

            this.loadModule = function(module, containerId) {
                var _this = this;
                return snap.getCachedScript(module.vmPath)
                    .then(function() {
                        //get ViewModel instance.
                        var vm = snap.resolveObject(module.vmName);
                        return _this.bindViewModel(vm, containerId, module.contentPath);
                    });
            };
        }).singleton();
}(jQuery, snap, kendo, window));
//@ sourceURL=dialogWindow.js

"use strict";
(function($, snap, kendo) {

    snap.namespace("snap.common").use(["snap.common.contentLoader"])
        .define("dialogWindow", function($contentLoader) {
            function Dialog(dialogOpt) {
                var currentDialog = null,
                    viewModel = null,
                    that = this;

                var buidingCurrentDialog = false;

                function open(opt) {
                    close();

                    var dfd = $.Deferred();

                    if (currentDialog === null) {
                        if (buidingCurrentDialog) {
                            return;
                        }
                        buidingCurrentDialog = true;

                        $contentLoader.bindViewModel(kendo.observable(dialogOpt.vm), dialogOpt.container, dialogOpt.contentPath).done(function(vm) {
                            viewModel = vm;

                            // If ViewModel contains any non MVVM logic, we will run it here.
                            if (typeof(viewModel.loadNonMVVM) === "function") {
                                viewModel.loadNonMVVM(dialogOpt.container);
                            }

                            var $container = $(dialogOpt.container);

                            $container.kendoWindow({
                                actions: [],
                                modal: true,
                                resizable: false
                            });

                            $('body').addClass("is-viewport-frozen");
                            $container.parent().addClass('dialogbox-modal');

                            currentDialog = $container.data("kendoWindow");
                            buidingCurrentDialog = false;

                            openDialog(currentDialog);
                        });
                    } else {
                        openDialog(currentDialog);
                    }

                    function openDialog(dialog) {
                        dialog.center();
                        dialog.open();

                        if (typeof(viewModel.setOptions) === "function") {
                            viewModel.setOptions({
                                dialog: that,
                                opt: opt
                            });
                        }

                        window.addEventListener("resize", resizeEventListener);

                        dfd.resolve();
                    }

                    return dfd;
                }

                function close() {
                    if (currentDialog) {
                        $('body').removeClass("is-viewport-frozen");
                        currentDialog.close();
                        window.removeEventListener("resize", resizeEventListener);
                    }
                }

                function resizeEventListener() {
                    window.console.log("resizeEventListener");

                    // Kendo has problem with center recalculation.
                    // Sometimes it do not correctly calculate center at first time.
                    $(".k-animation-container").css("display", "none");
                    rCenter(150, 3);
                }

                function rCenter(timeInterval, attempts) {
                    r(1);

                    function r(i) {
                        if (i > attempts)
                            return;

                        if (currentDialog) {
                            currentDialog.refresh();
                            currentDialog.center();
                        }

                        setTimeout(function() {
                            r(i + 1);
                        }, timeInterval);
                    }
                }

                /*********************** PUBLIC METHODS *****************************/
                this.open = function(opt) {
                    return open(opt);
                };

                this.close = function() {
                    close();
                };

                // Note!!! This is not a best approach, you should not use recursive refresh if there is exists clear way to center window.
                this.rCenter = function() {
                    rCenter(500, 20);
                };
            }

            /*********************** PUBLIC METHODS *****************************/
            this.createNewDialog = function(dialogOpt) {
                return new Dialog(dialogOpt);
            };
        }).singleton();
}(jQuery, snap, kendo));
//@ sourceURL=reEnterConsultation.viewmodel.js

(function($, snap, kendo) {
    "use strict";

    snap.namespace("snap.clinician.patientQueue")
        .use(["snapNotification", "snap.EventAggregator", "snap.service.appointmentService", "snap.common.schedule.ScheduleCommon", "snap.common.dialogWindow"])
        .extend(kendo.observable)
        .define("droppedConsultationViewModel", function($snapNotification, $eventAggregator, $appointmentService, $scheduleCommon, $dialogWindow) {
            var dialog = null;
            var droppedDialog = null;
            var dropdownlist;
            var consultationOpt = null;
            var userType;
            var $scope = this;
            this.markLabel = "Mark Complete";
            this.yesLabel = "Re-Enter";

            this.fullName = "";
            this.gender = "";
            this.age = "";
            this.selectedItem = null;
            this.patientStats = function() {
                if (this.gender.length > 0) {
                    var gender = this.gender == "M" ? "Male" : "Female";
                    return gender + "  " + this.age;
                }
            }
            this.addressState = "";
            this.addressCountry = "";
            this.patientProfileImage = "";
            this.vm_isError = false;
            this.vm_isLoading = false;
            this.vm_noStatus = true;
            this.vm_statusSet = !this.vm_noStatus;
            this.consultationDate = "";
            this.vm_getStartTime = function() {
                return [kendo.toString(this.consultationDate, "h:mm"), " <span>", kendo.toString(this.consultationDate, "tt"), "</span>"].join("");
            };
            this.vm_getStartDate = function() {
                return kendo.toString(this.consultationDate, "dddd, MMMM dd, yyyy");
            };
            this.patientInformation = null;
            this.consultationInfo = null;
            this.setOptions = function(opt) {
                dialog = opt.dialog;
                consultationOpt = opt.opt;
                var _this = this;
                userType = opt.opt.userType.userType;
                this.set("patientInformation", opt.opt.patientInformation);
                this.set("consultationInfo", opt.opt.consultationInfo);
                if (userType == 1) {
                    this.set("markLabel", "No");
                    this.set("yesLabel", "Yes");
                    this.set("consultationDate", new Date(opt.opt.consultationInfo.consultationDate));
                    this.set("fullName", opt.opt.patientInformation.fullName);
                    this.set("gender", opt.opt.patientInformation.gender);
                    this.set("age", opt.opt.patientInformation.age);
                    this.set("addressState", opt.opt.patientInformation.addressState);
                    this.set("addressCountry", opt.opt.patientInformation.addressCountry);
                    this.set("patientProfileImage", opt.opt.patientInformation.profileImage || "images/default-user.jpg");
                    this.trigger("change", { field: "patientStats" });
                    this.trigger("change", { field: "vm_getStartTime" });
                    this.trigger("change", { field: "vm_getStartDate" });

                } else {
                    this.set("markLabel", "Mark Complete");
                    this.set("yesLabel", "Re-Enter");
                }
                dropdownlist = $(".dialogbox__consultation-status-update").find(".js-dropdown-status").kendoDropDownList({
                    optionLabel: "Select a reason",
                    dataTextField: "text",
                    dataValueField: "codeId",
                    dataSource: [{
                        codeId: 72,
                        text: "Mark as Ended"
                    }, {
                        codeId: 81,
                        text: "Mark as Dropped"
                    }],
                    select: function(e) {
                        if (e.item) {
                            _this.selectedItem = this.dataItem(e.item);
                        }
                        $scope.set("vm_noStatus", false);
                        $scope.set("vm_statusSet", true);
                    },
                }).data("kendoDropDownList");
                //this.markLabel

            }.bind(this);
            this.vm_onDismissClick = function() {
                this._executeUpdateStatusChange(function() {
                    dialog.close();
                }.bind(this));
            }.bind(this);

            this._executeUpdateStatusChange = function(action) {
                var _this = this;
                this.set("vm_isLoading", true);
                $appointmentService.updateConsultationStatus(consultationOpt.consultationId, this.selectedItem.codeId)
                    .always(function() {
                        _this.set("vm_isLoading", false);
                    }).done(function(consultation) {
                        $snapNotification.info("Consultation saved.");
                        action();
                    }).fail(function() {
                        $snapNotification.error("Cannot check Consultation.");
                        dialog.close();
                    });
            };

            this.vm_onReEnterClick = function() {

                var videoConsultationLocation = userType === 1 ?
                    "/Physician/main#/consultation" :
                    "/Customer/main#/consultation?reload=1";

                var phoneConsultationLocation = "/Physician/main#/encounter/phone";

                this._executeOnConsultationCheck(function action(encounterType) {
                    snap.setSnapConsultationSessionData(consultationOpt);
                    if (encounterType === 2) {
                        window.location = phoneConsultationLocation;
                    } else {
                        window.location = videoConsultationLocation;
                    }

                });
            };
            this.openConsultationStatusSetDialog = function() {
                if (droppedDialog === null) {
                    droppedDialog = $dialogWindow.createNewDialog({
                        vm: {},
                        container: "#droppedConsultationPopUpContainer",
                        contentPath: "/content/clinician/patientQueue/droppedConsultation.html?v=1694"
                    });
                }
                droppedDialog.open({

                });
            };

            this.vm_onMarkCompleteClick = function() {
                if (userType == 1) {
                    dialog.close();
                    //open Consultation Status Changed Dialog
                    return this.openConsultationStatusSetDialog();
                } else {
                    var that = this;

                    var endConsultationAction = userType === 1 ? $appointmentService.clinicianEndActiveConsultaion : $appointmentService.patientEndActiveConsultaion;

                    var that = this;
                    this._executeOnConsultationCheck(function action() {
                        that.set("vm_isLoading", true);
                        endConsultationAction(consultationOpt.consultationId).done(function() {
                            $snapNotification.info("Consultation saved.");
                            dialog.close();
                            //$eventAggregator.published("consultation_markedAsComplete");
                        }).fail(function() {
                            $snapNotification.error("Cannot end consultation.");
                        }).always(function() {
                            that.set("vm_isLoading", false);
                        });
                    });
                }
            };

            this._executeOnConsultationCheck = function(action) {
                var that = this;
                that.set("vm_isLoading", true);
                $appointmentService.getConsultation(consultationOpt.consultationId)
                    .always(function() {
                        that.set("vm_isLoading", false);
                    }).done(function(consultation) {

                        // Check that consulttaion not disconnected or dropped.
                        var status = consultation.data[0].statusId;
                        if (status === 71 /*StartedConsultation*/ || status === 83 /*DisconnectedConsultation*/ ) {
                            action(consultation.data[0].encounterTypeCode);
                            dialog.close();
                        } else {
                            $snapNotification.error("Your consultation has expired.");
                            dialog.close();
                        }
                    }).fail(function() {
                        $snapNotification.error("Cannot check Consultation.");
                        dialog.close();
                    });
            };
        }).singleton();
}(jQuery, snap, kendo));

//@ sourceURL=reEnterConsultation.viewmodel.js

(function($, snap, kendo) {
    "use strict";

    snap.namespace("snap.clinician.patientQueue")
        .use(["snapNotification", "snap.EventAggregator", "snap.service.appointmentService", "snap.common.schedule.ScheduleCommon", "snap.clinician.patientQueue.droppedConsultationViewModel", "snap.common.dialogWindow"])
        .extend(kendo.observable)
        .define("reEnterConsultationDialog", function($snapNotification, $eventAggregator, $appointmentService, $scheduleCommon, $droppedConsultationViewModel, $dialogWindow) {
            var dialog = null;
            var droppedDialog = null;
            var consultationOpt = null;
            var userType;
            this.markLabel = "Mark Complete";
            this.yesLabel = "Re-Enter";
            this.fullName = "";
            this.gender = "";
            this.age = "";
            this.patientStats = function() {
                if (this.gender.length > 0) {
                    var gender = this.gender == "M" ? "Male" : "Female";
                    return gender + "  " + this.age;
                }
            }
            this.addressState = "";
            this.addressCountry = "";
            this.patientProfileImage = "";
            this.vm_isError = false;
            this.vm_isLoading = false;
            this.patientInformation = null;
            this.consultationInfo = null;
            this.setOptions = function(opt) {
                dialog = opt.dialog;
                consultationOpt = opt.opt;
                userType = opt.opt.userType;
                this.set("patientInformation", opt.opt.patientInformation);
                this.set("consultationInfo", opt.opt.consultationInfo);
                if (userType == 1) {
                    this.set("markLabel", "No");
                    this.set("yesLabel", "Yes");
                    this.set("fullName", opt.opt.patientInformation.fullName);
                    this.set("gender", opt.opt.patientInformation.gender);
                    this.set("age", opt.opt.patientInformation.age);
                    this.set("addressState", opt.opt.patientInformation.addressState);
                    this.set("addressCountry", opt.opt.patientInformation.addressCountry);
                    this.set("patientProfileImage", opt.opt.patientInformation.profileImage || "images/default-user.jpg");
                    this.trigger("change", { field: "patientStats" });

                } else {
                    this.set("markLabel", "Mark Complete");
                    this.set("yesLabel", "Re-Enter");
                }
                //this.markLabel

            }.bind(this);

            this.vm_onReEnterClick = function() {

                var videoConsultationLocation = userType === 1 ?
                    "/Physician/main#/consultation" :
                    "/Customer/main#/consultation?reload=1";

                var phoneConsultationLocation = "/Physician/main#/encounter/phone";

                this._executeOnConsultationCheck(function action(encounterType) {
                    snap.setSnapConsultationSessionData(consultationOpt);
                    if (encounterType === 2) {
                        window.location = phoneConsultationLocation;
                    } else {
                        window.location = videoConsultationLocation;
                    }

                });
            };
            this.openConsultationStatusSetDialog = function() {
                if (droppedDialog === null) {
                    droppedDialog = $dialogWindow.createNewDialog({
                        vm: $droppedConsultationViewModel,
                        container: "#droppedConsultationPopUpContainer",
                        contentPath: "/content/clinician/patientQueue/droppedConsultation.html?v=1694"
                    });
                }
                droppedDialog.open({
                    patientInformation: consultationOpt.patientInformation,
                    consultationInfo: consultationOpt.consultationInfo,
                    consultationId: consultationOpt.consultationId,
                    patientId: consultationOpt.patientId,
                    userType: consultationOpt,
                    meetingId: consultationOpt.meetingId,
                    personId: consultationOpt.providerPersonId
                });
            };

            this.vm_onMarkCompleteClick = function() {
                if (userType == 1) {
                    dialog.close();
                    //open Consultation Status Changed Dialog
                    return this.openConsultationStatusSetDialog();
                } else {
                    var that = this;

                    var endConsultationAction = userType === 1 ? $appointmentService.clinicianEndActiveConsultaion : $appointmentService.patientEndActiveConsultaion;

                    var that = this;
                    this._executeOnConsultationCheck(function action() {
                        that.set("vm_isLoading", true);
                        endConsultationAction(consultationOpt.consultationId).done(function() {
                            $snapNotification.info("Consultation saved.");
                            dialog.close();
                            //$eventAggregator.published("consultation_markedAsComplete");
                        }).fail(function() {
                            $snapNotification.error("Cannot end consultation.");
                        }).always(function() {
                            that.set("vm_isLoading", false);
                        });
                    });
                }
            };

            this._executeOnConsultationCheck = function(action) {
                var that = this;
                that.set("vm_isLoading", true);
                $appointmentService.getConsultation(consultationOpt.consultationId)
                    .always(function() {
                        that.set("vm_isLoading", false);
                    }).done(function(consultation) {
                        // Check that consulttaion not disconnected or dropped.
                        var status = consultation.data[0].statusId;
                        if (status === 71 /*StartedConsultation*/ || status === 83 /*DisconnectedConsultation*/ ) {
                            action(consultation.data[0].encounterTypeCode);
                            dialog.close();
                        } else {
                            $snapNotification.error("Your consultation has expired.");
                            dialog.close();
                        }
                    }).fail(function() {
                        $snapNotification.error("Cannot check Consultation.");
                        dialog.close();
                    });
            };
        }).singleton();
}(jQuery, snap, kendo));
